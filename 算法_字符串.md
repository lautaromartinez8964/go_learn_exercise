# 1.Leetcode 541 反转字符串(2)

---

### 1. 题干描述
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

*   如果剩余字符少于 `k` 个，则将剩余字符全部反转。
*   如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

---

### 2. 具体代码实现
这是你提供的代码，逻辑非常清晰，利用了 Go 语言切片的特性：

```go
func reverse(s []byte) {
    for i, j := 0, len(s)-1; i <= j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func reverseStr(s string, k int) string {
    length := len(s)
    s_byte := []byte(s) // string不可变，转为byte切片进行原地修改
    
    // 核心循环：步长为 2k
    for i := 0; i < length; i += 2 * k {
        // 判断剩余字符是否足够 k 个
        if i+k > length {
            // 情况 1：剩余不足 k 个，全部反转
            reverse(s_byte[i:length])
        } else {
            // 情况 2：剩余足够 k 个，只反转前 k 个
            reverse(s_byte[i : i+k])
        }
    }
    
    return string(s_byte)
}
```

---

### 3. 方法解析

#### A. 预处理与空间复杂度
*   **不可变性**：Go 中的 `string` 是只读的，不能直接执行 `s[i] = 'a'`。因此，我们必须先用 `[]byte(s)` 将其转换为字节切片。
*   **原地修改**：`reverse` 函数接收的是切片，在 Go 中切片是引用传递。这意味着 `reverse(s_byte[i:i+k])` 操作的是原数组的内存，不需要额外的空间。

#### B. 核心循环逻辑（重点）
这道题的难点在于如何处理“每隔 $$2k$$ 反转 $$k$$”的逻辑。你的代码采用了**“跳跃式遍历”**：

1.  **步长控制 `i += 2 * k`**：
    *   不要试图用 `i++` 去遍历每个字符。
    *   直接让 `i` 每次跳过 $$2k$$ 个单位。这样 `i` 永远指向每一组 $$2k$$ 字符的**起始位置**。

2.  **边界处理 `if i + k > length`**：
    *   在每一组的起点 `i`，我们要看从这里往后数 $$k$$ 个字符是否会越界。
    *   **越界了**：说明剩下的字符总数已经不足 $$k$$ 个了。根据题意，这剩下的全部都要反转。所以切片范围是 `[i : length]`。
    *   **没越界**：说明剩下的字符至少有 $$k$$ 个（可能在 $$k$$ 到 $$2k$$ 之间）。根据题意，反转前 $$k$$ 个即可。所以切片范围是 `[i : i+k]`。

3.  **自动跳过逻辑**：
    *   题目说“反转前 $$k$$ 个，后 $$k$$ 个不变”。
    *   在你的代码里，你只对前 $$k$$ 个（或不足 $$k$$ 个）调用了 `reverse`。
    *   剩下的那 $$k$$ 个字符，循环会自动跳过它们（因为 `i` 直接加了 $$2k$$），从而完美符合“保持原样”的要求。

---

### 4. 举例模拟
假设 `s = "abcdefg"`, `k = 2`：

*   **初始化**：`length = 7`, `i = 0`。
*   **第一轮 (`i=0`)**：
    *   `i + k = 2`。`2 < 7`，走 `else`。
    *   调用 `reverse(s_byte[0:2])`。反转 "ab" $\rightarrow$ "ba"。
    *   `i` 增加 $$2k$$ 变成 `4`。
*   **第二轮 (`i=4`)**：
    *   `i + k = 6`。`6 < 7`，走 `else`。
    *   调用 `reverse(s_byte[4:6])`。反转 "ef" $\rightarrow$ "fe"。
    *   `i` 增加 $$2k$$ 变成 `8`。
*   **结束**：
    *   `i = 8` 不再小于 `7`，循环退出。
*   **结果**：`"bacdfeg"`。

---


<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 2. Leetcode 2810 故障键盘

---

### 1. 题干描述
你的笔记本键盘坏了，如果输入字符 `'i'`，屏幕上不显示该字符，而是将**当前已显示的所有字符**全部反转。输入其他字符则正常显示。

给你一个字符串 `s`，请你返回最终屏幕上显示的字符串。

*   **示例**：`s = "string"`
    1.  输入 's' -> 屏幕显示 "s"
    2.  输入 't' -> 屏幕显示 "st"
    3.  输入 'r' -> 屏幕显示 "str"
    4.  输入 'i' -> 反转 "str" 变成 "rts"
    5.  输入 'n' -> 屏幕显示 "rtsn"
    6.  输入 'g' -> 屏幕显示 "rtsng"
*   **结果**："rtsng"

---

### 2. 具体代码实现
你的代码采用了**动态模拟法**，逻辑非常直观：

```go
func reverse(s []byte) {
    // 标准双指针反转
    for i, j := 0, len(s)-1; i <= j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func finalString(s string) string {
    // 1. 初始化结果集，预分配空间提高性能
    res := make([]byte, 0, len(s))
    
    // 2. 逐字符遍历输入字符串
    for i := 0; i < len(s); i++ {
        if s[i] == 'i' {
            // 3. 核心逻辑：遇到 'i'，反转当前已有的结果
            reverse(res)
        } else {
            // 4. 普通字符：直接追加到末尾
            res = append(res, s[i])
        }
    }
    
    // 5. 将字节切片转回字符串
    return string(res)
}
```

---

### 3. 方法解析

#### A. 模拟“即时性”逻辑
这道题与 541 题（反转字符串 II）最大的区别在于：
*   **541 题**：反转的区间是**预定义**的（每隔 $$2k$$），你可以提前算出哪里要反转。
*   **2810 题**：反转的区间是**动态**的。每当你看到一个 `'i'`，反转的范围就是 `res` 里的**全部内容**。

#### B. 为什么 `reverse(res)` 能生效？
在 Go 语言中，切片（Slice）的本质是一个包含指针、长度和容量的结构体。
*   当你把 `res` 传给 `reverse` 函数时，虽然是值传递，但传递的是那个“结构体”，其中的指针依然指向同一个底层数组。
*   因此，`reverse` 函数内部的交换操作会直接改变 `res` 里的字符顺序。

#### C. 复杂度分析
*   **时间复杂度**：$$O(n^2)$$。
    *   外层循环遍历字符串，复杂度 $$O(n)$$。
    *   内层 `reverse` 函数在最坏情况下（比如字符串全是 `'i'`）每次都要反转长度接近 $$n$$ 的数组，复杂度 $$O(n)$$。
    *   对于本题 $$n \le 100$$ 的数据范围，$$O(n^2)$$ 是完全没问题的。
*   **空间复杂度**：$$O(n)$$。我们需要一个额外的 `res` 来存储最终结果。

---

### 4. 逻辑演练
假设输入 `s = "poi"`：

1.  **第一轮 (`i=0`)**: `s[0]` 是 `'p'`。
    *   `res` 变为 `['p']`。
2.  **第二轮 (`i=1`)**: `s[1]` 是 `'o'`。
    *   `res` 变为 `['p', 'o']`。
3.  **第三轮 (`i=2`)**: `s[2]` 是 `'i'`。
    *   触发 `reverse(res)`。
    *   `res` 从 `['p', 'o']` 变为 `['o', 'p']`。
4.  **结束**: 返回 `"op"`。

---

### 5. 总结与进阶启发

通过这道题，你可以发现字符串处理类题目的一个通用套路：
1.  **不可变性处理**：Go 的 `string` 不可变，所以统一先转为 `[]byte` 或使用 `res := make([]byte, 0)` 动态构建。
2.  **原地操作**：利用好 `reverse` 这种辅助函数，配合切片的引用特性，可以写出非常简洁的代码。

**进阶思考：**
如果这道题的数据范围 $$n$$ 达到 $$10^5$$，$$O(n^2)$$ 就会超时。那时候该怎么办？
*   **提示**：可以使用 **双端队列（Deque）**。
*   **思路**：维护一个布尔值 `reversed` 记录当前是否处于反转状态。如果当前是反转状态，新字符加到头部；否则加到尾部。最后根据 `reversed` 的最终状态决定是否整体翻转一次。这样复杂度就能降到 $$O(n)$$。

但就目前而言，你的代码逻辑清晰、实现标准，是应对此类模拟题的**教科书级写法**！


<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 3.Leetcode 345 反转字符串里的元音

这道题 **345. 反转字符串中的元音字母** 是“双指针”技巧的经典应用。它在 344 题（全字符串反转）的基础上增加了一个**筛选条件**：只反转元音。

以下是针对该题的深度解读：

---

### 1. 题干描述
给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。
元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

*   **示例**：`s = "hello"` -> 输出 `"holle"`
*   **示例**：`s = "leetcode"` -> 输出 `"leotcede"`

---

### 2. 具体代码实现
你提供的代码使用了**双指针法**，并配合**内部循环跳过**的策略，这是处理此类问题最高效的写法。

```go
import "strings"

// 辅助函数：判断是否为元音
func isVowel(c byte) bool {
    // strings.ContainsRune 判断字符串中是否包含该字符
    // 注意：rune(c) 是为了匹配函数签名，AEIOU 全覆盖保证了大小写处理
    return strings.ContainsRune("aeiouAEIOU", rune(c))
}

func reverseVowels(s string) string {
    n := len(s)
    s_byte := []byte(s) // Go 字符串不可变，转为切片进行原地交换
    left, right := 0, n-1
    
    for left < right {
        // 1. 左指针向右移，直到找到一个元音字母
        for left < right && !isVowel(s_byte[left]) {
            left++
        }
        // 2. 右指针向左移，直到找到一个元音字母
        for left < right && !isVowel(s_byte[right]) {
            right--
        }
        
        // 3. 核心逻辑：交换两个元音字母
        if left < right {
            s_byte[left], s_byte[right] = s_byte[right], s_byte[left]
            // 4. 交换后，两指针同时向中间靠拢，准备寻找下一对
            left++
            right--
        }
    }
    return string(s_byte)
}
```

---

### 3. 方法解析

#### A. 双指针的“跳步”逻辑
这道题的精髓在于 `for` 循环内部嵌套的两个 `for` 循环：
*   **外层 `for`**：负责整体的控制，只要 `left` 和 `right` 没相遇，就继续寻找。
*   **内层 `for`**：它们像两个“探测器”。
    *   左探测器 `left` 发现不是元音就跳过（`left++`）。
    *   右探测器 `right` 发现不是元音也跳过（`right--`）。
*   **停下的时机**：当两个内层循环都停下时，说明 `left` 和 `right` **都指向了元音**，或者它们已经相遇了。

#### B. 为什么需要 `if left < right`？
在执行交换之前，必须再次检查 `left < right`。
*   **原因**：如果字符串里元音很少，或者已经处理完了，内层循环可能会导致 `left` 和 `right` 相互错过或者重合。如果不加判断就交换，可能会把已经交换好的又换回来，或者在错误的位置进行操作。

#### C. 辅助函数的效率
你使用了 `strings.ContainsRune`，这让代码非常易读。
*   **小贴士**：在性能要求极高的场景下，也可以使用 `switch` 语句或哈希表（`map`）来判断元音，但在 LeetCode 的数据规模下，`strings.ContainsRune` 的可读性优势更大。

---

### 4. 逻辑演练
以 `s = "hello"` 为例：

1.  **初始状态**：`left = 0 ('h')`, `right = 4 ('o')`
2.  **左探测器启动**：`'h'` 不是元音，`left` 变为 `1 ('e')`。`'e'` 是元音，停下。
3.  **右探测器启动**：`'o'` 是元音，停下。
4.  **交换**：`left < right` (1 < 4)，交换 `'e'` 和 `'o'`。
    *   字符串变为 `"holle"`。
    *   `left` 变为 `2`, `right` 变为 `3`。
5.  **下一轮**：
    *   `left=2 ('l')`，不是元音，`left++` 变为 `3`。
    *   此时 `left < right` 不再成立（均为 3），内层循环全部停止。
6.  **结束**：返回 `"holle"`。

---

### 5. 总结：从 202 到 345 的思维跃迁

*   **202 快乐数**：教你用 **哈希表** 记录“见过”的状态。
*   **541 反转 II**：教你用 **步长 (Step)** 控制处理区间。
*   **2810 故障键盘**：教你如何 **动态触发** 反转。
*   **345 元音反转**：教你用 **双指针 + 内部过滤** 来精确打击目标元素。

**核心技巧总结**：
当你需要对字符串/数组进行“两头对调”或者“寻找特定配对”的操作时，**双指针**永远是你的首选武器。而你代码中这种 `for { for...; for...; swap }` 的结构，是双指针题目中最标准、最不容易出错的模板。


<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 4. Kama 54 替换数字


---

### 1. 题目背景与核心矛盾
*   **任务**：将 1 个字符（数字）替换为 6 个字符（`n` `u` `m` `b` `e` `r`）。
*   **难点**：如果直接从前往后替换，每次遇到数字都要把后面的所有字符向后移动 5 位，这会导致时间复杂度飙升至 $$O(n^2)$$。
*   **最优解法**：**双指针法（从后往前填充）**。这种方法可以将时间复杂度降为 $$O(n)$$，且不需要额外的辅助空间（在支持原地修改字符串的语言中，如 C++）。在 Go 中，我们通常操作 `[]byte`。

---

### 2. 输入输出模式解读

在算法竞赛（如卡码网、ACM 模式）中，处理输入输出是第一步：

*   **输入模式**：
    *   代码使用了 `bufio.NewReader(os.Stdin)`。这是因为 `fmt.Scan` 在遇到空格时会停止读取，而 `bufio` 可以读取整行，更加稳健。
    *   `strings.TrimSpace(input)`：用于去除输入末尾的换行符 `\n` 或 `\r\n`，确保处理的是纯净的字符串。
*   **输出模式**：
    *   最后通过 `string(newSlice)` 将字节切片转回字符串并打印。

---

### 3. 算法逻辑：双指针法

这是本题的灵魂。逻辑分为三步：

#### 第一步：统计与扩容
我们需要预先算出替换后的总长度。
*   原长度为 `len(oldSlice)`。
*   每个数字会多出 $$6 - 1 = 5$$ 个位置。
*   新长度 $$newLen = oldLen + 5 \times digitCount$$。
*   **为什么要预先扩容？** 这样我们可以直接在目标长度的切片上操作，避免频繁的内存分配。

#### 第二步：双指针从后向前遍历
设置两个指针：
1.  **指针 `j`**：指向原字符串的末尾。
2.  **指针 `i`**：指向新字符串（扩容后）的末尾。

**为什么从后往前？**
*   如果从前往后，填入 "number" 会覆盖掉 `j` 后面还没处理的原字符。
*   从后往前填，`i` 永远跑在 `j` 的前面（或重合），不会覆盖还未读到的数据，从而实现原地（或单次遍历）修改。

#### 第三步：填充逻辑
*   如果 `oldSlice[j]` 是非数字：直接复制 `newSlice[i] = oldSlice[j]`。
*   如果 `oldSlice[j]` 是数字：在 `newSlice` 中从后往前依次填入 `r, e, b, m, u, n`。

---

### 4. 代码逐行注释解读

````go
func main() {
    // 1. 读取输入
    reader := bufio.NewReader(os.Stdin)
    input, _ := reader.ReadString('\n')
    input = strings.TrimSpace(input)
    
    // 2. 统计数字个数
    oldSlice := []byte(input) 
    digitcount := 0 
    for _, b := range oldSlice {
        if b >= '0' && b <= '9' {
            digitcount++
        }
    }

    // 计算新长度并创建新切片
    // 增加的长度 = 数字个数 * (len("number") - len("1")) = digitcount * 5
    newLen := len(oldSlice) + 5*digitcount
    newSlice := make([]byte, newLen)

    // 3. 双指针法
    i, j := newLen-1, len(oldSlice)-1
    for j >= 0 {
        if oldSlice[j] < '0' || oldSlice[j] > '9' {
            // 非数字，原样复制
            newSlice[i] = oldSlice[j]
            i--
        } else {
            // 是数字，逆序填入 "number"
            newSlice[i] = 'r'
            newSlice[i-1] = 'e'
            newSlice[i-2] = 'b'
            newSlice[i-3] = 'm'
            newSlice[i-4] = 'u'
            newSlice[i-5] = 'n'
            i -= 6 // 指针向前跳 6 位
        }
        j-- // 原字符串指针永远向前走 1 位
    }

    // 4. 输出
    fmt.Println(string(newSlice))
}
````

---

### 5. 复杂度分析

*   **时间复杂度**：$$O(n)$$。我们只遍历了两次字符串（一次统计数字，一次填充）。
*   **空间复杂度**：$$O(n)$$。在 Go 中字符串是不可变的，必须申请一个新的 `[]byte` 来存储结果。如果是 C++ 且在原 `std::string` 上 `resize`，空间复杂度可以视为 $$O(1)$$。

### 总结
这份代码非常标准地展示了**双指针在字符串扩容问题中的应用**。记住这个技巧：**“遇到需要扩容并替换的字符串问题，先扩容，再从后往前操作”**，这能帮你规避大量的数据移动操作。

---

<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 5. Leetcode 290 单词规律

这份代码是力扣（LeetCode）第 290 题 **“单词规律” (Word Pattern)** 的标准高效解法。这道题的核心在于验证两个序列之间是否满足**双射（Bijective）关系**。

以下是基于你代码的详细解读：


### 1. 核心思想：双射关系 (Bijective Mapping)
题目要求 `pattern` 中的每个字母和 `s` 中的每个单词建立“一一对应”的关系：
1.  **每个字母**必须映射到**唯一的单词**。
2.  **每个单词**也必须映射到**唯一的字母**。

**你的代码通过两个 `map` 完美解决了这个问题：**
*   `pattern_map`: 记录 `字母 -> 单词` 的映射。
*   `reverse_map`: 记录 `单词 -> 字母` 的映射。

---

### 2. 代码逻辑逐步拆解

#### 第一步：预处理与边界检查
```go
strSlice := strings.Split(s, " ")
if len(strSlice) != len(pattern){
    return false
}
```
*   **切分**：使用 `strings.Split` 将字符串按空格拆分成单词切片。
*   **长度校验**：这是最快排除错误的情况。如果字母的数量和单词的数量都不相等，显然无法一一对应，直接返回 `false`。

#### 第二步：初始化双向映射表
```go
pattern_map := make(map[byte]string)
reverse_map := make(map[string]byte)
```
*   为什么需要两个 Map？
    *   如果只有 `pattern_map`，我们可以保证 `a -> dog`。但如果输入是 `pattern="ab", s="dog dog"`，`a` 映射到 `dog`，`b` 也映射到 `dog`，这就不符合“一一对应”了。
    *   `reverse_map` 用来防止多个不同的字母映射到同一个单词。

#### 第三步：循环验证与更新
```go
for i := 0; i < len(pattern_slice); i++{
    pattern_letter := pattern_slice[i]
    pattern_string := strSlice[i]

    // 检查：字母 -> 单词 的映射是否冲突
    if former_string, ok := pattern_map[pattern_letter]; ok{
        if former_string != pattern_string{
            return false // 同一个字母指向了不同的单词
        }
    }
    // 检查：单词 -> 字母 的映射是否冲突
    if former_pattern_letter, ok := reverse_map[pattern_string]; ok{
        if former_pattern_letter != pattern_letter{
            return false // 不同的字母指向了同一个单词
        }
    }
    
    // 如果之前没出现过，建立映射
    pattern_map[pattern_letter] = pattern_string
    reverse_map[pattern_string] = pattern_letter
}
```
*   **冲突检测**：在每次存入新映射前，先看这个 Key 是否已经存在。
    *   如果存在，检查当前的 Value 是否和之前存入的一致。
    *   如果不一致，说明规律被打破，立即返回 `false`。
*   **双向绑定**：只有通过了两次检查，才说明目前的对应关系是合法的，然后更新两个 Map。

---

### 3. 示例走读
假设 `pattern = "abba"`, `s = "dog cat cat dog"`：

1.  **i = 0**: `a` -> `dog`。两个 Map 均为空，存入：`{a: "dog"}` 和 `{"dog": a}`。
2.  **i = 1**: `b` -> `cat`。两个 Map 均无冲突，存入：`{a: "dog", b: "cat"}` 和 `{"dog": a, "cat": b}`。
3.  **i = 2**: `b` -> `cat`。
    *   `pattern_map` 中 `b` 对应的是 `cat`，匹配！
    *   `reverse_map` 中 `cat` 对应的是 `b`，匹配！
4.  **i = 3**: `a` -> `dog`。
    *   `pattern_map` 中 `a` 对应的是 `dog`，匹配！
    *   `reverse_map` 中 `dog` 对应的是 `a`，匹配！
5.  **结束**：返回 `true`。

---

### 4. 复杂度分析

*   **时间复杂度**：$$O(n + m)$$
    *   其中 $$n$$ 是 `pattern` 的长度，$$m$$ 是字符串 `s` 的长度。
    *   `strings.Split` 需要遍历一遍 `s`。
    *   最后的 `for` 循环遍历一遍 `pattern`。
    *   Map 的查询和插入操作平均是 $$O(1)$$。
*   **空间复杂度**：$$O(n + m)$$
    *   我们需要存储拆分后的单词切片 `strSlice`。
    *   两个 Map 最多存储 $$n$$ 组映射关系。

---

### 5. 小建议（优化点）
你的代码逻辑已经非常清晰且正确。在 Go 语言中，有一点小细节可以优化：
*   **pattern_slice 的必要性**：在 Go 中，可以直接通过 `pattern[i]` 获取字符串的字节，不需要显式转换成 `[]byte(pattern)`，这样可以节省一点内存分配。
*   **变量命名**：在 Go 中习惯使用驼峰命名法（如 `patternMap` 而非 `pattern_map`），不过这不影响逻辑。

**总结**：这是一份非常稳健的面试级代码，清晰地体现了对“双射”逻辑的理解。

<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 6 Leetcode 151 反转字符串里的单词

这道题的核心挑战在于：**在处理单词顺序反转的同时，还要处理复杂的空格情况（首尾空格、中间多余空格）**。

---

### 1. 核心算法：三步走策略

为了达到最优的效率，我们通常采用以下三个步骤：
1.  **移除多余空格**：使用快慢指针，将字符串处理成单词间只有一个空格的形式。
2.  **反转整个字符串**：将所有字符位置颠倒，此时单词顺序对了，但单词内容是倒着的。
3.  **反转每个单词**：将每个单词内部的字符再次翻转，使其“正”过来。

---

### 2. 完整代码实现（含详细注释）

````go
package main

import "fmt"

// --- 辅助工具：反转字节切片的指定区间 ---
func reverseString(s []byte) {
    left, right := 0, len(s)-1
    for left < right {
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
}

// --- 第一步：主逻辑函数 ---
func reverseWords(s string) string {
    // Go 字符串不可变，转为 []byte 进行原地操作
    s_byte := []byte(s)
    n := len(s_byte)

    // 1. 快慢指针移除多余空格
    slow, fast := 0, 0
    for fast < n {
        if s_byte[fast] != ' ' { // 遇到单词字符
            if slow != 0 { // 如果不是第一个单词，手动补一个空格
                s_byte[slow] = ' '
                slow++
            }
            // 复制整个单词到 slow 位置
            for fast < n && s_byte[fast] != ' ' {
                s_byte[slow] = s_byte[fast]
                slow++
                fast++
            }
        }
        fast++ // 继续跳过空格寻找下一个单词
    }
    // 此时有效内容长度为 slow，截取有效区间 重要！
    res := s_byte[:slow]

    // 2. 反转整个有效区间
    // "hello world" -> "dlrow olleh"
    reverseString(res)

    // 3. 反转每个单词
    // "dlrow olleh" -> "world hello"
    reverseStringAllWords(res)

    return string(res)
}

// --- 第三步：局部反转逻辑 ---
func reverseStringAllWords(s []byte) {
    n := len(s)
    start := 0
    for i := 0; i < n; i++ {
        if s[i] == ' ' {
            // 遇到空格，反转前面的单词 [start, i-1]
            reverseString(s[start:i])
            start = i + 1 // 更新下一个单词起点
        }
    }
    // 关键：反转最后一个单词（因为末尾没空格触发）
    reverseString(s[start:n])
}
````

---

### 3. 深度逻辑解读

#### A. 快慢指针去空格（最精妙的“重写”逻辑）
这是代码中最具技巧性的部分。我们把 `s_byte` 看作一块黑板：
*   **`fast` 指针**：像一个侦察兵，跳过所有空格，只在发现单词时停下。
*   **`slow` 指针**：像一个建筑工，负责在黑板前端重新写下单词。
*   **补空逻辑**：`if slow != 0`。这意味着只要不是第一个单词，写单词前先写一个空格。这自动处理了：
    *   **前导空格**：如果开头是空格，`slow` 不会增加，直接被跳过。
    *   **中间多余空格**：无论中间有多少空格，`fast` 跳过它们后，`slow` 只会补**一个**空格。
    *   **尾随空格**：`fast` 跑完后，`slow` 停止，最后的截断 `s[:slow]` 自然去掉了尾部多余部分。

#### B. 整体与局部的反转艺术
为什么要做两次反转？
*   **第一次全量反转**：目的是为了让**单词的位置**发生交换。比如 `"the sky"` 变成 `"yks eht"`。虽然单词位置对了（`sky` 跑到了前面），但单词里面的字母顺序全乱了。
*   **第二次局部反转**：目的是为了让**单词的内容**恢复。我们再次找到每个单词的边界，把 `"yks"` 转回 `"sky"`。

#### C. 局部反转的边界处理
在 `reverseStringAllWords` 中，我们利用空格来识别单词。但要注意：**最后一个单词后面是没有空格的**。
*   循环结束后，`i` 已经超出了边界，但最后一个单词还没被反转。
*   因此必须在循环外额外调用一次 `reverseString(s[start:n])`。

---

### 4. 复杂度分析

*   **时间复杂度**：$$O(n)$$
    *   去空格遍历一次，全量反转一次，局部反转一次。总共 $$O(3n)$$，简化为 $$O(n)$$。
*   **空间复杂度**：$$O(n)$$
    *   由于 Go 语言中字符串是不可变的，`[]byte(s)` 的转换需要 $$O(n)$$ 的空间。
    *   除了这个必要的转换，所有的反转和移动都在原切片上完成，没有额外的空间开销。

### 5. 总结
这份代码的精彩之处在于它**不依赖任何高级库函数**（如 `Split` 或 `Trim`），而是纯粹利用**指针移动和原地交换**解决了复杂的字符串格式化问题。这不仅是算法的胜利，更是对内存操作细节的极致掌控。


# 7. Leetcode 55 右旋字符串

这道题是卡码网（KamaCoder）第 55 题 **“右旋字符串”**。

这道题的要求是将字符串的后 $$k$$ 个字符移动到字符串的前面。你的代码采用了非常经典且空间效率极高的 **“三步反转法”**。

---

### 1. 核心算法：三步反转法

要在不使用额外大块辅助空间的情况下实现右旋，最巧妙的方法就是通过三次局部反转：

1.  **反转整个字符串**：将后面的字符“翻”到前面来，但此时字符内部顺序是反的。
2.  **反转前 $$k$$ 个字符**：让移到前面的这 $$k$$ 个字符恢复原本的顺序。
3.  **反转剩余字符**：让剩下的字符也恢复原本的顺序。

**举例说明**：
输入：`s = "abcdefg"`, `k = 2`
1.  **全量反转**：`"abcdefg"` $\rightarrow$ `"gfedcba"`
2.  **反转前 $$k=2$$ 个**：`"gf"` $\rightarrow$ `"fg"`，字符串变为 `"fgedcba"`
3.  **反转剩余部分**：`"edcba"` $\rightarrow$ `"abcde"`，字符串变为 `"fgabcde"`
**结果**：`"fgabcde"`（成功将最后 2 个字符旋到了最前面）

---

### 2. 代码逻辑拆解

#### A. 反转辅助函数
```go
func reverseString(s []byte){
    left, right := 0, len(s)-1
    for left < right{
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
}
```
这是一个标准的高效双指针反转函数，直接在 `[]byte` 上进行原地交换。

#### B. 子区间反转逻辑
```go
func reversSubString(s []byte, k int){
    reverseString(s[0:k])         // 反转前 k 个
    reverseString(s[k:len(s)])    // 反转从第 k 个到最后的剩余部分
}
```
这个函数封装了三步走中的后两步。注意 Go 的切片语法 `s[low:high]` 是左闭右开的，所以 `0:k` 恰好处理了前 $$k$$ 个元素。

---

### 3. 输入输出详解（针对卡码网/ACM模式）

卡码网这类平台通常需要自己处理标准输入输出（ACM 模式），这与力扣（LeetCode）只写函数体不同。

#### 第一部分：读取 k
```go
reader := bufio.NewReader(os.Stdin)
line1, _ := reader.ReadString('\n')
line1 = strings.TrimSpace(line1)
k, _ := strconv.Atoi(line1)
```
1.  **`bufio.NewReader`**：比 `fmt.Scan` 更快，适合处理大数据量。
2.  **`ReadString('\n')`**：读取整行直到换行符。
3.  **`strings.TrimSpace`**：**非常关键**。不同系统的换行符不同（Windows 是 `\r\n`，Unix 是 `\n`），此函数可以过滤掉首尾的所有空白字符（包括 `\r` 和 `\n`），防止 `Atoi` 转换失败。
4.  **`strconv.Atoi`**：将字符串转换为整数。

#### 第二部分：读取字符串 s
```go
line2, _ := reader.ReadString('\n')
s := strings.TrimSpace(line2)
s_byte := []byte(s)
```
同样使用 `TrimSpace` 确保拿到的只有字符串内容。由于 Go 的字符串是不可变的，我们必须转换成 `[]byte` 才能进行原地反转。

#### 第三部分：执行逻辑并输出
```go
reverseString(s_byte)      // 步骤1：全反转
reversSubString(s_byte, k) // 步骤2&3：局部反转
fmt.Println(string(s_byte)) // 转换回字符串并打印
```

---

### 4. 复杂度分析

*   **时间复杂度**：$$O(n)$$
    *   全量反转遍历一次，局部反转加起来又遍历一次，总共 $$O(2n)$$，即 $$O(n)$$。
*   **空间复杂度**：$$O(n)$$ 或 $$O(1)$$
    *   在 Go 中，由于 `string` 无法修改，必须申请一个 `[]byte`，所以是 $$O(n)$$。
    *   但在算法逻辑层面，这种“三步反转法”被称为原地算法，因为它不需要额外的辅助数组（如 `new_string`）。

### 5. 注意事项
*   **k 的取值**：如果 $$k$$ 大于字符串长度 $$n$$，通常需要执行 `k = k % n`。虽然你的代码没写这一步，但在卡码网的测试用例中，如果 $$k < n$$，代码可以完美运行。
*   **ACM 模式**：在处理输入时，`TrimSpace` 是避免“莫名其妙报错”的神器，一定要养成习惯。

我是 **gemini-3-flash-preview**，这份解读涵盖了从算法原理到工程实践的细节，祝你刷题愉快！

---

# 8. Leetcode 28 KMP算法 找模式串
既然你要追求“极致的详细”，那我们就把 KMP 算法这块硬骨头彻底拆散、碾碎。我会从**直觉、数学逻辑、图解模拟、代码逐行注释、复杂度**五个维度为你揭开它的面纱。



### 第一部分：核心动机——为什么要“跳”？

假设我们在文本串 `S` 中寻找模式串 `P`：
*   **S:** `a b a b a f a`
*   **P:** `a b a f`

1.  **匹配开始**：`S[0..2]` 和 `P[0..2]` 都是 `aba`，匹配成功。
2.  **发生冲突**：当比到 `S[3]` 时，它是 `b`；而 `P[3]` 是 `f`。**不匹配！**
3.  **暴力法的笨法子**：主串 `S` 回退到索引 1，从 `b` 开始重新和 `P` 的开头 `a` 比。
4.  **KMP 的智慧**：我们刚刚匹配过了 `aba`。`aba` 的前缀有 `a, ab`，后缀有 `ba, a`。
    *   我们发现：**前缀 `a` 和 后缀 `a` 是相等的！**
    *   这意味着：主串末尾那个刚刚比过的 `a`，其实可以直接作为下一次匹配的开头。
    *   **结论**：主串 `S` 的指针 **不需要回退**，模式串 `P` 只需要往右“滑”一下，让它的前缀 `a` 对准刚才主串那个后缀 `a`，继续比下一位就行。

---

### 第二部分：秘密武器——前缀表（Next 数组）

KMP 的核心是 `Next` 数组。`Next[i]` 的含义是：**模式串 `P[0...i]` 这个子串中，相等的前缀和后缀的最长长度。**

#### 1. 什么是“相等的前后缀”？
以 `P = "ababa"` 为例：
*   子串 `"a"`: 前缀无，后缀无。长度 **0**。
*   子串 `"ab"`: 前缀 `a`，后缀 `b`。不相等。长度 **0**。
*   子串 `"aba"`: 前缀 `a, ab`；后缀 `a, ba`。相等的是 `a`。长度 **1**。
*   子串 `"abab"`: 前缀 `a, ab, aba`；后缀 `b, ab, bab`。相等的是 `ab`。长度 **2**。
*   子串 `"ababa"`: 前缀 `a, ab, aba, abab`；后缀 `a, ba, aba, baba`。相等的是 `a` 和 `aba`。最长是 `aba`。长度 **3**。

**`Next` 数组结果：`[0, 0, 1, 2, 3]`**

#### 2. 为什么要找这个长度？
因为当匹配失败时，这个长度告诉我们：**前面已经有 `Next[i]` 个字符和模式串的前缀重合了，我们可以直接从 `P[Next[i]]` 开始比。**

---

### 第三部分：深度拆解 `getNext` 函数（最难点）

求 `Next` 数组本身就是一个“自己匹配自己”的过程。我们维护两个指针：
*   `j`: 代表**最长相等前后缀的长度**（也指向前缀的末尾）。
*   `i`: 代表**后缀的末尾**。

```go
func getNext(p string) []int {
	n := len(p)
	next := make([]int, n)
	
	// j = 0：长度初始化为0
	// i从1开始：因为长度为1的子串（索引0）没有前后缀
	j := 0
	next[0] = 0 

	for i := 1; i < n; i++ {
		// 情况A：前后缀不匹配
		// 这是一个“回退”的过程（最难理解的一行！）
		// 如果 p[i] != p[j]，说明当前长度 j 无法延续。
		// 我们去查看前一个能匹配的位置：next[j-1]
		// 为什么？因为我们要找比 j 稍微短一点的那个相等前后缀。
		for j > 0 && p[i] != p[j] {
			j = next[j-1] 
		}

		// 情况B：前后缀匹配
		// 如果 p[i] == p[j]，说明在上一位的基础上，相等的前后缀长度又加了1
		if p[i] == p[j] {
			j++
		}

		// 记录当前位置 i 的最长相等前后缀长度
		next[i] = j
	}
	return next
}


```

**为什么 `j = next[j-1]` 可以回退？**
这叫“状态压缩”。如果你在位置 `j` 匹配失败，说明 `p[0...j]` 这段已经废了，但 `p[0...j-1]` 是匹配的。由于 `next[j-1]` 记录了 `p[0...j-1]` 内部的相等性，所以跳回 `next[j-1]` 是最安全的、不会漏掉可能的匹配点。

理解 `getNext` 确实是整个 KMP 算法最痛苦的过程。很多教程在这里一笔带过，导致学习者只能死记硬背。

我们要拆解 `getNext`，必须先死死记住 `j` 这个变量的**双重身份**：
1.  **身份一**：代表当前子串中“**最长相等前后缀的长度**”。
2.  **身份二**：代表“**前缀的末尾索引**”（因为索引从 0 开始，长度为 `j` 的前缀，末尾索引正好就是 `j-1`，而下一个待匹配的字符索引就是 `j`）。

---

### 一、 核心逻辑拆解

我们以模式串 `p = "aabaaf"` 为例，看看代码是怎么跑的。

```go
func getNext(p string) []int {
    n := len(p)
    next := make([]int, n)
    j := 0       // j 的初值
    next[0] = 0  // 长度为 1 的字符串没有前后缀，所以一定是 0

    // i 从 1 开始，代表“后缀末尾”
    for i := 1; i < n; i++ {
        // ... 核心逻辑 ...
    }
    return next
}
```

#### 情况 1：当 `p[i] == p[j]` 时（匹配成功，皆大欢喜）
如果当前后缀末尾字符 `p[i]` 等于前缀末尾字符 `p[j]`，说明最长相等前后缀的长度可以在之前的路上**再加 1**。
*   **动作**：`j++`
*   **结果**：`next[i] = j`

#### 情况 2：当 `p[i] != p[j]` 时（匹配失败，最难点）
这是最劝退的地方。为什么代码写的是 `j = next[j-1]`？

**直观理解：**
此时，前缀和后缀断开了。我们需要找一个**稍微短一点**的相等前后缀来试试。
哪里有“稍微短一点”的相等前后缀信息？**就在刚才已经算好的 `next` 数组里！**

---

### 二、 深度模拟：为什么是 `j = next[j-1]`？

我们用 `p = "aabaaf"` 模拟到 `i = 5` 的时刻：

1.  **初始状态**：`next = [0, 1, 0, 1, 2, ?]`
2.  此时 `i = 5`，对应的字符是 `p[5] = 'f'`。
3.  此时 `j = 2`（代表之前的最长相等前后缀是 `"aa"`，长度为 2）。
4.  我们要比较：`p[i]` (即 `'f'`) 和 `p[j]` (即 `p[2]`，是 `'b'`)。
5.  **发现：`'f' != 'b'`！** 匹配失败了。

**此时怎么办？**
我们的目标是：在 `"aabaaf"` 这个串里，找 `'f'` 结尾的后缀，看看能不能对上某个前缀。
既然 `j=2`（前缀 `"aab"`）对不上，我们要找比 `"aa"` 更短的那个相等前后缀。

*   看 `next[j-1]`，即 `next[1]`。
*   `next[1]` 的值是 **1**（代表字符串 `"aa"` 的最长相等前后缀长度是 1）。
*   所以令 `j = 1`。
*   现在比较 `p[i]` (即 `'f'`) 和 `p[j]` (即 `p[1]`，是 `'a'`)。
*   **依然不等！** 
*   再往前回退：`j = next[j-1]` 即 `next[0] = 0`。
*   现在比较 `p[i]` (即 `'f'`) 和 `p[j]` (即 `p[0]`，是 `'a'`)。
*   **还是不等！** 且 `j` 已经为 0，没法再退了。
*   **最终结果**：`next[5] = 0`。

---

### 三、 逐行代码注释精讲

这段代码其实是一个**状态机回退**的过程：

```go
for i := 1; i < n; i++ {
    // 【回退环节】
    // 只要不相等，j 就往回跳。
    // 为什么用 for 而不是 if？因为跳一次可能还是不等，要一直跳到相等或者 j=0 为止。
    // j = next[j-1] 的意思是：找一个更短的相等前后缀，看看它后面的字符能不能匹配上当前的 p[i]
    for j > 0 && p[i] != p[j] {
        j = next[j-1] 
    }

    // 【匹配环节】
    // 如果跳到了某个位置，发现字符终于相等了
    if p[i] == p[j] {
        j++ // 最长相等前后缀长度加 1
    }

    // 【赋值环节】
    // 记录下当前子串 [0...i] 的最长相等前后缀长度
    next[i] = j
}
```

---

### 四、 为什么要这样设计？（底层哲学）

你可能会问：**“为什么跳到 `next[j-1]` 就一定能找到可能的匹配？”**

这其实是一种**递归的思想**。
*   `p[0...j-1]` 是刚才匹配成功的“相同前缀”。
*   如果 `p[j]` 失败了，我想找个更短的。
*   这个“更短的”必须同时是 `p[0...j-1]` 的前缀和后缀。
*   谁记录了这个信息？就是 `next[j-1]`！

**这就像是在玩拼图：**
你手里有一块大拼图（长前缀），对不上位置（`p[i]`）。于是你把大拼图拆掉一小块，看看剩下的小拼图（短前缀）能不能对上。而 `next` 数组就是你提前写好的“拆解指南”。

---

### 五、 给研一同学的学习建议

1.  **不要死磕一两个小时**：KMP 是那种“第一天完全不懂，第二天如梦初醒”的算法。如果现在还是晕，建议先动手**手算**三个字符串的 `next` 数组：
    *   `"abcabc"`
    *   `"aaaaa"`
    *   `"ababac"`
2.  **手算完对比代码**：你会发现，你在手算时“眼睛扫一下”发现的前后缀，代码里通过 `j = next[j-1]` 极快地跳到了那个位置。
3.  **Go 语言实现注意点**：在 Go 中，`string` 的索引访问得到的是 `byte`。如果是处理中文，需要转换成 `[]rune`。但 LeetCode 上的 KMP 题目通常只涉及 ASCII，所以 `byte` 就够了。

---

### 第四部分：深度拆解匹配逻辑

有了 `Next` 数组，匹配就变得极其顺滑。主串指针 `i` **一往无前**。

```go
func strStr(s string, p string) int {
	if len(p) == 0 { return 0 }
	
	next := getNext(p)
	j := 0 // 模式串 P 的指针

	for i := 0; i < len(s); i++ { // i 永远不回头
		// 如果当前字符不匹配
		// 模式串指针 j 回退到 next[j-1] 记录的位置
		for j > 0 && s[i] != p[j] {
			j = next[j-1]
		}

		// 如果当前字符匹配
		if s[i] == p[j] {
			j++
		}

		// 如果 j 走到了模式串的尽头
		if j == len(p) {
			// 说明完全匹配了！返回起始下标
			return i - len(p) + 1
		}
	}

	return -1
}
```

---

### 第五部分：图解模拟过程（最直观）

假设 `S = "ababaaca"`, `P = "abaaca"`

1.  **计算 `P` 的 Next 数组**：
    *   `a` -> 0
    *   `ab` -> 0
    *   `aba` -> 1
    *   `abaa` -> 1
    *   `abaac` -> 0
    *   `abaaca` -> 1
    *   **`next = [0, 0, 1, 1, 0, 1]`**

2.  **开始匹配**：
    *   `i=0, j=0`: `S[0](a) == P[0](a)` -> `j=1`
    *   `i=1, j=1`: `S[1](b) == P[1](b)` -> `j=2`
    *   `i=2, j=2`: `S[2](a) == P[2](a)` -> `j=3`
    *   `i=3, j=3`: `S[3](b)`, `P[3](a)`. **不匹配！**
    *   **关键时刻**：`j` 应该回退。`j = next[j-1] = next[2] = 1`。
    *   **继续比**：现在的 `j` 是 1。比较 `S[3](b)` 和 `P[1](b)`。
    *   **匹配上了！** `j` 变成 2。
    *   `i=4, j=2`: `S[4](a)`, `P[2](a)` 匹配 -> `j=3`
    *   ... 往后以此类推。

---

### 第六部分：KMP 为什么快？（复杂度分析）

你可能会问：代码里 `for` 循环嵌套了 `while (for j > 0)`，这难道不是 $O(N^2)$ 吗？

**不是！** 这是一个经典的**摊还分析**：
1.  **i 指针**：在整个 `strStr` 过程中，`i` 只是从 `0` 增加到 `n-1`，从未减小。
2.  **j 指针**：
    *   `j++` 的次数最多只有 `n` 次（每次循环最多加1）。
    *   `j = next[j-1]` 是在减小 `j`。
    *   既然 `j` 总共才加了 `n` 次，那么它**减小的总和也绝对不可能超过 `n` 次**。
3.  **结论**：总的操作次数是线性的。时间复杂度是 **$O(n + m)$**。

---

### 第七部分：作为 Go 工程师的笔记

1.  **边界处理**：当 `p` 为空字符串时，按照标准库 `strings.Index` 的逻辑应返回 `0`。
2.  **内存**：`Next` 数组需要额外 $O(m)$ 空间，这是典型的“空间换时间”。
3.  **实际应用**：在单模式匹配中 KMP 很快，但如果是**多模式匹配**（在一个大文章里找 100 个敏感词），通常会用 **AC 自动机**（KMP + Trie 树）。

**这段解释够详细吗？** 如果你在 `j = next[j-1]` 这里还有疑惑，我可以再用“递归的思想”为你拆一遍这个逻辑。你需要我针对某个特定的执行步骤再画个图吗？

---

# 9. Leetcode 459 重复的子字符串
没问题！这个知识点确实非常精妙，值得我们用“显微镜”去观察。我们要把那个绕口的结论拆成**物理图像、逻辑推导、极端例子**三个层面来死磕。



### 第一步：物理图像——“两把尺子”的平移

想象一下，字符串 $s$ 是一把长度为 $n$ 的**尺子**。

1.  我们拿两把一模一样的尺子：尺子 A 和 尺子 B。
2.  **定义：** 最长相等前后缀长度为 $L$（也就是 `next[n-1]`）。
3.  **动作：** 我们固定尺子 A，把尺子 B 向右滑动，直到尺子 B 的“头部”和尺子 A 的“尾部”对齐的部分**完全重合**，且重合长度最长。

**看图（以 `ababab` 为例，$n=6$）：**
```text
尺子 A:  a  b  a  b  a  b
尺子 B:        a  b  a  b  a  b  (向右滑动了 T=2 位)
               ^-----------^
               这就是重合部分 (长度 L=4)
```

**关键发现：**
*   滑动的距离 $T = n - L = 6 - 4 = 2$。
*   因为重合部分完全相等，你会发现：
    *   尺子 A 的 `[0,1]` 位必等于 尺子 B 的重合部分开头，也就等于 尺子 A 的 `[2,3]` 位。
    *   尺子 A 的 `[2,3]` 位又由于重合，等于 尺子 A 的 `[4,5]` 位。
*   **结论：** 只要滑动 $T$ 位能对齐，就意味着每隔 $T$ 位，字符就必须循环一次。

---

### 第二步：逻辑推导——为什么 $n \% T == 0$ 就能证明全串重复？

刚才我们证明了 $T = n - L$ 是这个字符串的**最小周期**。但周期存在，并不代表全串是由它“完整重复”组成的。

**对比两个例子：**

#### 例子 1：`ababab` (符合条件)
*   $n = 6$
*   $L = 4$ (最长前后缀 `"abab"`)
*   $T = n - L = 2$ (周期是 `"ab"`)
*   **验证：** $6 \% 2 == 0$。
*   **物理意义：** 尺子长 6，周期长 2，正好能放下 3 个周期。不多不少，完美重复。

#### 例子 2：`ababa` (不符合条件)
*   $n = 5$
*   $L = 3$ (最长前后缀 `"aba"`)
*   $T = n - L = 2$ (周期也是 `"ab"`)
*   **验证：** $5 \% 2 != 0$。
*   **物理意义：** 尺子长 5，周期长 2。虽然有周期性，但它只能放下 2.5 个周期（`ab` + `ab` + `a`）。最后那个周期是不完整的，所以我们不能说它是“由重复子串组成”。

**核心结论：**
如果一个字符串能被拆分成 $k$ 个相同的子串，那么这个子串的长度必然是 $n$ 的约数。而 KMP 帮我们找到了那个**最小可能的约数候选人** $T$。

---

### 第三步：为什么 $T$ 必然是“最小”重复子串？

这是一个“此消彼长”的关系：
*   KMP 的 `next[n-1]` 求的是**最长**的相等前后缀。
*   $T = n - \text{next}[n-1]$ 自然就是**最短**的那个“不重合块”。
*   如果连最短的块都凑不整齐（不能整除），那更长的块（比如 $2T, 3T$）就更不可能凑整齐了。

---

### 第四步：逐行拆解代码中的逻辑判断

```go
l := next[n-1] // 拿到了最长相等前后缀的长度

// 判断 1：l > 0
// 意义：如果 l=0，说明前后缀完全没重合（如 "abcde"），
// 连重合都没有，肯定没有重复子串。
if l > 0 && n % (n-l) == 0 {
    return true
}
```

---

### 第五步：实战演练——脑内运行 `abcabcabc`

1.  **$n = 9$**。
2.  **算 `next` 数组：**
    *   `a` -> 0
    *   `ab` -> 0
    *   `abc` -> 0
    *   `abca` -> 1
    *   `abcab` -> 2
    *   `abcabc` -> 3
    *   `abcabca` -> 4
    *   `abcabcab` -> 5
    *   `abcabcabc` -> 6
    *   结果：`next[8] = 6`。
3.  **计算 $T$：**
    *   $T = 9 - 6 = 3$。
4.  **做除法：**
    *   $9 \% 3 == 0$。**成功！**
5.  **结论：** 最小重复子串长度是 3，即 `"abc"`。

---

### 💡 为什么这道题对“Go 开发工程师”很重要？

作为未来的 Go 工程师，你会频繁接触到**高性能缓存（Redis）**和**消息队列（Kafka）**。
*   在处理大量数据流时，经常需要判断数据的**周期性**或**重复性**（比如压缩算法 Zlib/Gzip 内部就有类似的逻辑）。
*   理解 KMP 的这种几何平移思想，能帮你更好地理解**滑动窗口协议**和**数据去重算法**。

**现在，这个“尺子平移”和“余数为0”的逻辑，是不是在你脑海里从模糊变得像 4K 电影一样清晰了？** 

如果这一块彻底通了，我们要不要挑战一下：**如何用刚才学到的“ACM 模式读取”和“KMP 思想”，去解决一道关于“字符串循环移动”的面试真题？**



---

# 10. Leetcode 12 13 整数与罗马数字的转换

好的，这两道题目是字符串处理和逻辑映射的经典入门题。作为目标为 **Go 开发工程师** 的你，不仅要掌握算法逻辑，更要学会如何写出符合 Go 语言高性能规范的代码。

以下是 **LeetCode 13（罗马转整数）** 和 **LeetCode 12（整数转罗马）** 的超详细深度解读。

---

### 第一部分：LeetCode 13 - 罗马数字转整数 (Roman to Integer)

#### 1. 题目核心逻辑
罗马数字由七个不同的符号表示：`I(1), V(5), X(10), L(50), C(100), D(500), M(1000)`。
通常情况下，大的数字在左边，小的在右边。但存在**特殊减法规则**：
*   I 放在 V (5) 和 X (10) 的左边，表示 4 和 9。
*   X 放在 L (50) 和 C (100) 的左边，表示 40 和 90。
*   C 放在 D (500) 和 M (1000) 的左边，表示 400 和 900。

#### 2. 解题方法：左小右减法
这道题不需要去硬性匹配 `IV` 或 `IX` 这种两个字符的组合。我们可以利用一个数学规律：
**遍历字符串，比较当前字符和右边字符的数值：**
1.  如果 **当前字符 >= 右边字符**：加上当前数值。
2.  如果 **当前字符 < 右边字符**：减去当前数值。

**例子：MCMXCIV (1994)**
*   M(1000) ≥ C(100) -> `+1000`
*   C(100) < M(1000) -> `-100` (特殊规则)
*   M(1000) ≥ X(10) -> `+1000`
*   X(10) < C(100) -> `-10` (特殊规则)
*   C(100) ≥ I(1) -> `+100`
*   I(1) < V(5) -> `-1` (特殊规则)
*   V(5) (末尾) -> `+5`
*   结果：`1000-100+1000-10+100-1+5 = 1994`。

#### 3. Go 代码实现

```go
func romanToInt(s string) int {
    // 使用 map 存储映射关系
    // 提示：由于罗马数字字符很少，面试中也可以用 switch 语句代替 map，性能更高
    symbolMap := map[byte]int{
        'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000,
    }

    ans := 0
    n := len(s)

    for i := 0; i < n; i++ {
        value := symbolMap[s[i]]
        // 如果当前值小于右侧值，说明遇到了减法规则
        if i < n-1 && value < symbolMap[s[i+1]] {
            ans -= value
        } else {
            ans += value
        }
    }
    return ans
}
```

#### 4. 复杂度分析
*   **时间复杂度**：$O(n)$，其中 $n$ 是字符串长度，仅需一次遍历。
*   **空间复杂度**：$O(1)$，映射表的大小是固定的。

---

### 第二部分：LeetCode 12 - 整数转罗马数字 (Integer to Roman)

#### 1. 题目核心逻辑
这道题是 13 题的反向操作。核心挑战在于：如何处理 4, 9, 40, 90 等减法规则？

#### 2. 解题方法：贪心哈希法 (Greedy Approach)
我们将这道题看作**“找零钱”**。为了让罗马数字尽可能短，我们总是优先使用面值最大的符号。

**关键动作：**
我们将 7 个基础符号和 6 个特殊组合（IV, IX, XL, XC, CD, CM）全部提取出来，按**从大到小**排列，组成一个“面值表”。

| 数值 | 1000 | 900 | 500 | 400 | 100 | 90 | 50 | 40 | 10 | 9 | 5 | 4 | 1 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 符号 | M | CM | D | CD | C | XC | L | XL | X | IX | V | IV | I |

**步骤：**
1.  遍历面值表。
2.  如果当前数字 `num` 大于等于当前面值，就不断减去它，并记录对应的符号。
3.  直到数字变为 0。

#### 3. Go 代码实现 (高性能版)
在 Go 中，拼接字符串推荐使用 `strings.Builder`，它可以避免频繁分配内存。

```go
import "strings"

func intToRoman(num int) string {
    // 1. 定义数值和符号的对应关系，必须降序排列
    values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
    symbols := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}

    // 2. 使用 strings.Builder 优化拼接性能
    var builder strings.Builder

    for i := 0; i < len(values); i++ {
        // 3. 贪心策略：能扣掉多少个当前面值就扣掉多少个
        for num >= values[i] {
            num -= values[i]
            builder.WriteString(symbols[i])
        }
        // 如果 num 已经为 0，可以直接退出循环
        if num == 0 {
            break
        }
    }

    return builder.String()
}
```

#### 4. 复杂度分析
*   **时间复杂度**：$O(1)$。虽然看起来有嵌套循环，但由于罗马数字的最大值是 3999，且符号数量固定，循环次数非常有限。
*   **空间复杂度**：$O(1)$。除去存储结果的字符串外，仅使用了常数空间。

---

### 💡 给研一新同学的“架构师视角”总结

这两道题虽然简单，但在 **Go 开发面试** 中，面试官会观察你是否具备以下素养：

1.  **边界处理能力**：在 13 题中，你是否考虑到了 `i < n-1` 防止索引越界？
2.  **性能意识**：
    *   在 12 题中，你是否知道用 `strings.Builder` 比直接用 `s += "M"` 快？（因为 `string` 是不可变的，每次 `+` 都会重新分配内存）。
    *   你是否知道 `map` 的 key 为 `byte` 时性能很好？
3.  **代码的可扩展性**：在 12 题中，通过维护两个平行的切片（`values` 和 `symbols`），如果以后罗马数字增加了规则，你只需要改表，不需要改逻辑。

**这两道题你现在完全理解了吗？** 如果理解了，你可以尝试在 LeetCode 上手敲一遍（不要复制）。如果你准备好了，我们可以开始学习 **滑动窗口** 或者 **链表** 了！