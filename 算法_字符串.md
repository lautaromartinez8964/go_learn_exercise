# 1.Leetcode 541 反转字符串(2)

---

### 1. 题干描述
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

*   如果剩余字符少于 `k` 个，则将剩余字符全部反转。
*   如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

---

### 2. 具体代码实现
这是你提供的代码，逻辑非常清晰，利用了 Go 语言切片的特性：

```go
func reverse(s []byte) {
    for i, j := 0, len(s)-1; i <= j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func reverseStr(s string, k int) string {
    length := len(s)
    s_byte := []byte(s) // string不可变，转为byte切片进行原地修改
    
    // 核心循环：步长为 2k
    for i := 0; i < length; i += 2 * k {
        // 判断剩余字符是否足够 k 个
        if i+k > length {
            // 情况 1：剩余不足 k 个，全部反转
            reverse(s_byte[i:length])
        } else {
            // 情况 2：剩余足够 k 个，只反转前 k 个
            reverse(s_byte[i : i+k])
        }
    }
    
    return string(s_byte)
}
```

---

### 3. 方法解析

#### A. 预处理与空间复杂度
*   **不可变性**：Go 中的 `string` 是只读的，不能直接执行 `s[i] = 'a'`。因此，我们必须先用 `[]byte(s)` 将其转换为字节切片。
*   **原地修改**：`reverse` 函数接收的是切片，在 Go 中切片是引用传递。这意味着 `reverse(s_byte[i:i+k])` 操作的是原数组的内存，不需要额外的空间。

#### B. 核心循环逻辑（重点）
这道题的难点在于如何处理“每隔 $$2k$$ 反转 $$k$$”的逻辑。你的代码采用了**“跳跃式遍历”**：

1.  **步长控制 `i += 2 * k`**：
    *   不要试图用 `i++` 去遍历每个字符。
    *   直接让 `i` 每次跳过 $$2k$$ 个单位。这样 `i` 永远指向每一组 $$2k$$ 字符的**起始位置**。

2.  **边界处理 `if i + k > length`**：
    *   在每一组的起点 `i`，我们要看从这里往后数 $$k$$ 个字符是否会越界。
    *   **越界了**：说明剩下的字符总数已经不足 $$k$$ 个了。根据题意，这剩下的全部都要反转。所以切片范围是 `[i : length]`。
    *   **没越界**：说明剩下的字符至少有 $$k$$ 个（可能在 $$k$$ 到 $$2k$$ 之间）。根据题意，反转前 $$k$$ 个即可。所以切片范围是 `[i : i+k]`。

3.  **自动跳过逻辑**：
    *   题目说“反转前 $$k$$ 个，后 $$k$$ 个不变”。
    *   在你的代码里，你只对前 $$k$$ 个（或不足 $$k$$ 个）调用了 `reverse`。
    *   剩下的那 $$k$$ 个字符，循环会自动跳过它们（因为 `i` 直接加了 $$2k$$），从而完美符合“保持原样”的要求。

---

### 4. 举例模拟
假设 `s = "abcdefg"`, `k = 2`：

*   **初始化**：`length = 7`, `i = 0`。
*   **第一轮 (`i=0`)**：
    *   `i + k = 2`。`2 < 7`，走 `else`。
    *   调用 `reverse(s_byte[0:2])`。反转 "ab" $\rightarrow$ "ba"。
    *   `i` 增加 $$2k$$ 变成 `4`。
*   **第二轮 (`i=4`)**：
    *   `i + k = 6`。`6 < 7`，走 `else`。
    *   调用 `reverse(s_byte[4:6])`。反转 "ef" $\rightarrow$ "fe"。
    *   `i` 增加 $$2k$$ 变成 `8`。
*   **结束**：
    *   `i = 8` 不再小于 `7`，循环退出。
*   **结果**：`"bacdfeg"`。

---


<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 2. Leetcode 2810 故障键盘

---

### 1. 题干描述
你的笔记本键盘坏了，如果输入字符 `'i'`，屏幕上不显示该字符，而是将**当前已显示的所有字符**全部反转。输入其他字符则正常显示。

给你一个字符串 `s`，请你返回最终屏幕上显示的字符串。

*   **示例**：`s = "string"`
    1.  输入 's' -> 屏幕显示 "s"
    2.  输入 't' -> 屏幕显示 "st"
    3.  输入 'r' -> 屏幕显示 "str"
    4.  输入 'i' -> 反转 "str" 变成 "rts"
    5.  输入 'n' -> 屏幕显示 "rtsn"
    6.  输入 'g' -> 屏幕显示 "rtsng"
*   **结果**："rtsng"

---

### 2. 具体代码实现
你的代码采用了**动态模拟法**，逻辑非常直观：

```go
func reverse(s []byte) {
    // 标准双指针反转
    for i, j := 0, len(s)-1; i <= j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func finalString(s string) string {
    // 1. 初始化结果集，预分配空间提高性能
    res := make([]byte, 0, len(s))
    
    // 2. 逐字符遍历输入字符串
    for i := 0; i < len(s); i++ {
        if s[i] == 'i' {
            // 3. 核心逻辑：遇到 'i'，反转当前已有的结果
            reverse(res)
        } else {
            // 4. 普通字符：直接追加到末尾
            res = append(res, s[i])
        }
    }
    
    // 5. 将字节切片转回字符串
    return string(res)
}
```

---

### 3. 方法解析

#### A. 模拟“即时性”逻辑
这道题与 541 题（反转字符串 II）最大的区别在于：
*   **541 题**：反转的区间是**预定义**的（每隔 $$2k$$），你可以提前算出哪里要反转。
*   **2810 题**：反转的区间是**动态**的。每当你看到一个 `'i'`，反转的范围就是 `res` 里的**全部内容**。

#### B. 为什么 `reverse(res)` 能生效？
在 Go 语言中，切片（Slice）的本质是一个包含指针、长度和容量的结构体。
*   当你把 `res` 传给 `reverse` 函数时，虽然是值传递，但传递的是那个“结构体”，其中的指针依然指向同一个底层数组。
*   因此，`reverse` 函数内部的交换操作会直接改变 `res` 里的字符顺序。

#### C. 复杂度分析
*   **时间复杂度**：$$O(n^2)$$。
    *   外层循环遍历字符串，复杂度 $$O(n)$$。
    *   内层 `reverse` 函数在最坏情况下（比如字符串全是 `'i'`）每次都要反转长度接近 $$n$$ 的数组，复杂度 $$O(n)$$。
    *   对于本题 $$n \le 100$$ 的数据范围，$$O(n^2)$$ 是完全没问题的。
*   **空间复杂度**：$$O(n)$$。我们需要一个额外的 `res` 来存储最终结果。

---

### 4. 逻辑演练
假设输入 `s = "poi"`：

1.  **第一轮 (`i=0`)**: `s[0]` 是 `'p'`。
    *   `res` 变为 `['p']`。
2.  **第二轮 (`i=1`)**: `s[1]` 是 `'o'`。
    *   `res` 变为 `['p', 'o']`。
3.  **第三轮 (`i=2`)**: `s[2]` 是 `'i'`。
    *   触发 `reverse(res)`。
    *   `res` 从 `['p', 'o']` 变为 `['o', 'p']`。
4.  **结束**: 返回 `"op"`。

---

### 5. 总结与进阶启发

通过这道题，你可以发现字符串处理类题目的一个通用套路：
1.  **不可变性处理**：Go 的 `string` 不可变，所以统一先转为 `[]byte` 或使用 `res := make([]byte, 0)` 动态构建。
2.  **原地操作**：利用好 `reverse` 这种辅助函数，配合切片的引用特性，可以写出非常简洁的代码。

**进阶思考：**
如果这道题的数据范围 $$n$$ 达到 $$10^5$$，$$O(n^2)$$ 就会超时。那时候该怎么办？
*   **提示**：可以使用 **双端队列（Deque）**。
*   **思路**：维护一个布尔值 `reversed` 记录当前是否处于反转状态。如果当前是反转状态，新字符加到头部；否则加到尾部。最后根据 `reversed` 的最终状态决定是否整体翻转一次。这样复杂度就能降到 $$O(n)$$。

但就目前而言，你的代码逻辑清晰、实现标准，是应对此类模拟题的**教科书级写法**！


<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 3.Leetcode 345 反转字符串里的元音

这道题 **345. 反转字符串中的元音字母** 是“双指针”技巧的经典应用。它在 344 题（全字符串反转）的基础上增加了一个**筛选条件**：只反转元音。

以下是针对该题的深度解读：

---

### 1. 题干描述
给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。
元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。

*   **示例**：`s = "hello"` -> 输出 `"holle"`
*   **示例**：`s = "leetcode"` -> 输出 `"leotcede"`

---

### 2. 具体代码实现
你提供的代码使用了**双指针法**，并配合**内部循环跳过**的策略，这是处理此类问题最高效的写法。

```go
import "strings"

// 辅助函数：判断是否为元音
func isVowel(c byte) bool {
    // strings.ContainsRune 判断字符串中是否包含该字符
    // 注意：rune(c) 是为了匹配函数签名，AEIOU 全覆盖保证了大小写处理
    return strings.ContainsRune("aeiouAEIOU", rune(c))
}

func reverseVowels(s string) string {
    n := len(s)
    s_byte := []byte(s) // Go 字符串不可变，转为切片进行原地交换
    left, right := 0, n-1
    
    for left < right {
        // 1. 左指针向右移，直到找到一个元音字母
        for left < right && !isVowel(s_byte[left]) {
            left++
        }
        // 2. 右指针向左移，直到找到一个元音字母
        for left < right && !isVowel(s_byte[right]) {
            right--
        }
        
        // 3. 核心逻辑：交换两个元音字母
        if left < right {
            s_byte[left], s_byte[right] = s_byte[right], s_byte[left]
            // 4. 交换后，两指针同时向中间靠拢，准备寻找下一对
            left++
            right--
        }
    }
    return string(s_byte)
}
```

---

### 3. 方法解析

#### A. 双指针的“跳步”逻辑
这道题的精髓在于 `for` 循环内部嵌套的两个 `for` 循环：
*   **外层 `for`**：负责整体的控制，只要 `left` 和 `right` 没相遇，就继续寻找。
*   **内层 `for`**：它们像两个“探测器”。
    *   左探测器 `left` 发现不是元音就跳过（`left++`）。
    *   右探测器 `right` 发现不是元音也跳过（`right--`）。
*   **停下的时机**：当两个内层循环都停下时，说明 `left` 和 `right` **都指向了元音**，或者它们已经相遇了。

#### B. 为什么需要 `if left < right`？
在执行交换之前，必须再次检查 `left < right`。
*   **原因**：如果字符串里元音很少，或者已经处理完了，内层循环可能会导致 `left` 和 `right` 相互错过或者重合。如果不加判断就交换，可能会把已经交换好的又换回来，或者在错误的位置进行操作。

#### C. 辅助函数的效率
你使用了 `strings.ContainsRune`，这让代码非常易读。
*   **小贴士**：在性能要求极高的场景下，也可以使用 `switch` 语句或哈希表（`map`）来判断元音，但在 LeetCode 的数据规模下，`strings.ContainsRune` 的可读性优势更大。

---

### 4. 逻辑演练
以 `s = "hello"` 为例：

1.  **初始状态**：`left = 0 ('h')`, `right = 4 ('o')`
2.  **左探测器启动**：`'h'` 不是元音，`left` 变为 `1 ('e')`。`'e'` 是元音，停下。
3.  **右探测器启动**：`'o'` 是元音，停下。
4.  **交换**：`left < right` (1 < 4)，交换 `'e'` 和 `'o'`。
    *   字符串变为 `"holle"`。
    *   `left` 变为 `2`, `right` 变为 `3`。
5.  **下一轮**：
    *   `left=2 ('l')`，不是元音，`left++` 变为 `3`。
    *   此时 `left < right` 不再成立（均为 3），内层循环全部停止。
6.  **结束**：返回 `"holle"`。

---

### 5. 总结：从 202 到 345 的思维跃迁

*   **202 快乐数**：教你用 **哈希表** 记录“见过”的状态。
*   **541 反转 II**：教你用 **步长 (Step)** 控制处理区间。
*   **2810 故障键盘**：教你如何 **动态触发** 反转。
*   **345 元音反转**：教你用 **双指针 + 内部过滤** 来精确打击目标元素。

**核心技巧总结**：
当你需要对字符串/数组进行“两头对调”或者“寻找特定配对”的操作时，**双指针**永远是你的首选武器。而你代码中这种 `for { for...; for...; swap }` 的结构，是双指针题目中最标准、最不容易出错的模板。


<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 4. Kama 54 替换数字


---

### 1. 题目背景与核心矛盾
*   **任务**：将 1 个字符（数字）替换为 6 个字符（`n` `u` `m` `b` `e` `r`）。
*   **难点**：如果直接从前往后替换，每次遇到数字都要把后面的所有字符向后移动 5 位，这会导致时间复杂度飙升至 $$O(n^2)$$。
*   **最优解法**：**双指针法（从后往前填充）**。这种方法可以将时间复杂度降为 $$O(n)$$，且不需要额外的辅助空间（在支持原地修改字符串的语言中，如 C++）。在 Go 中，我们通常操作 `[]byte`。

---

### 2. 输入输出模式解读

在算法竞赛（如卡码网、ACM 模式）中，处理输入输出是第一步：

*   **输入模式**：
    *   代码使用了 `bufio.NewReader(os.Stdin)`。这是因为 `fmt.Scan` 在遇到空格时会停止读取，而 `bufio` 可以读取整行，更加稳健。
    *   `strings.TrimSpace(input)`：用于去除输入末尾的换行符 `\n` 或 `\r\n`，确保处理的是纯净的字符串。
*   **输出模式**：
    *   最后通过 `string(newSlice)` 将字节切片转回字符串并打印。

---

### 3. 算法逻辑：双指针法

这是本题的灵魂。逻辑分为三步：

#### 第一步：统计与扩容
我们需要预先算出替换后的总长度。
*   原长度为 `len(oldSlice)`。
*   每个数字会多出 $$6 - 1 = 5$$ 个位置。
*   新长度 $$newLen = oldLen + 5 \times digitCount$$。
*   **为什么要预先扩容？** 这样我们可以直接在目标长度的切片上操作，避免频繁的内存分配。

#### 第二步：双指针从后向前遍历
设置两个指针：
1.  **指针 `j`**：指向原字符串的末尾。
2.  **指针 `i`**：指向新字符串（扩容后）的末尾。

**为什么从后往前？**
*   如果从前往后，填入 "number" 会覆盖掉 `j` 后面还没处理的原字符。
*   从后往前填，`i` 永远跑在 `j` 的前面（或重合），不会覆盖还未读到的数据，从而实现原地（或单次遍历）修改。

#### 第三步：填充逻辑
*   如果 `oldSlice[j]` 是非数字：直接复制 `newSlice[i] = oldSlice[j]`。
*   如果 `oldSlice[j]` 是数字：在 `newSlice` 中从后往前依次填入 `r, e, b, m, u, n`。

---

### 4. 代码逐行注释解读

````go
func main() {
    // 1. 读取输入
    reader := bufio.NewReader(os.Stdin)
    input, _ := reader.ReadString('\n')
    input = strings.TrimSpace(input)
    
    // 2. 统计数字个数
    oldSlice := []byte(input) 
    digitcount := 0 
    for _, b := range oldSlice {
        if b >= '0' && b <= '9' {
            digitcount++
        }
    }

    // 计算新长度并创建新切片
    // 增加的长度 = 数字个数 * (len("number") - len("1")) = digitcount * 5
    newLen := len(oldSlice) + 5*digitcount
    newSlice := make([]byte, newLen)

    // 3. 双指针法
    i, j := newLen-1, len(oldSlice)-1
    for j >= 0 {
        if oldSlice[j] < '0' || oldSlice[j] > '9' {
            // 非数字，原样复制
            newSlice[i] = oldSlice[j]
            i--
        } else {
            // 是数字，逆序填入 "number"
            newSlice[i] = 'r'
            newSlice[i-1] = 'e'
            newSlice[i-2] = 'b'
            newSlice[i-3] = 'm'
            newSlice[i-4] = 'u'
            newSlice[i-5] = 'n'
            i -= 6 // 指针向前跳 6 位
        }
        j-- // 原字符串指针永远向前走 1 位
    }

    // 4. 输出
    fmt.Println(string(newSlice))
}
````

---

### 5. 复杂度分析

*   **时间复杂度**：$$O(n)$$。我们只遍历了两次字符串（一次统计数字，一次填充）。
*   **空间复杂度**：$$O(n)$$。在 Go 中字符串是不可变的，必须申请一个新的 `[]byte` 来存储结果。如果是 C++ 且在原 `std::string` 上 `resize`，空间复杂度可以视为 $$O(1)$$。

### 总结
这份代码非常标准地展示了**双指针在字符串扩容问题中的应用**。记住这个技巧：**“遇到需要扩容并替换的字符串问题，先扩容，再从后往前操作”**，这能帮你规避大量的数据移动操作。

---

<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 5. Leetcode 290 单词规律

这份代码是力扣（LeetCode）第 290 题 **“单词规律” (Word Pattern)** 的标准高效解法。这道题的核心在于验证两个序列之间是否满足**双射（Bijective）关系**。

以下是基于你代码的详细解读：


### 1. 核心思想：双射关系 (Bijective Mapping)
题目要求 `pattern` 中的每个字母和 `s` 中的每个单词建立“一一对应”的关系：
1.  **每个字母**必须映射到**唯一的单词**。
2.  **每个单词**也必须映射到**唯一的字母**。

**你的代码通过两个 `map` 完美解决了这个问题：**
*   `pattern_map`: 记录 `字母 -> 单词` 的映射。
*   `reverse_map`: 记录 `单词 -> 字母` 的映射。

---

### 2. 代码逻辑逐步拆解

#### 第一步：预处理与边界检查
```go
strSlice := strings.Split(s, " ")
if len(strSlice) != len(pattern){
    return false
}
```
*   **切分**：使用 `strings.Split` 将字符串按空格拆分成单词切片。
*   **长度校验**：这是最快排除错误的情况。如果字母的数量和单词的数量都不相等，显然无法一一对应，直接返回 `false`。

#### 第二步：初始化双向映射表
```go
pattern_map := make(map[byte]string)
reverse_map := make(map[string]byte)
```
*   为什么需要两个 Map？
    *   如果只有 `pattern_map`，我们可以保证 `a -> dog`。但如果输入是 `pattern="ab", s="dog dog"`，`a` 映射到 `dog`，`b` 也映射到 `dog`，这就不符合“一一对应”了。
    *   `reverse_map` 用来防止多个不同的字母映射到同一个单词。

#### 第三步：循环验证与更新
```go
for i := 0; i < len(pattern_slice); i++{
    pattern_letter := pattern_slice[i]
    pattern_string := strSlice[i]

    // 检查：字母 -> 单词 的映射是否冲突
    if former_string, ok := pattern_map[pattern_letter]; ok{
        if former_string != pattern_string{
            return false // 同一个字母指向了不同的单词
        }
    }
    // 检查：单词 -> 字母 的映射是否冲突
    if former_pattern_letter, ok := reverse_map[pattern_string]; ok{
        if former_pattern_letter != pattern_letter{
            return false // 不同的字母指向了同一个单词
        }
    }
    
    // 如果之前没出现过，建立映射
    pattern_map[pattern_letter] = pattern_string
    reverse_map[pattern_string] = pattern_letter
}
```
*   **冲突检测**：在每次存入新映射前，先看这个 Key 是否已经存在。
    *   如果存在，检查当前的 Value 是否和之前存入的一致。
    *   如果不一致，说明规律被打破，立即返回 `false`。
*   **双向绑定**：只有通过了两次检查，才说明目前的对应关系是合法的，然后更新两个 Map。

---

### 3. 示例走读
假设 `pattern = "abba"`, `s = "dog cat cat dog"`：

1.  **i = 0**: `a` -> `dog`。两个 Map 均为空，存入：`{a: "dog"}` 和 `{"dog": a}`。
2.  **i = 1**: `b` -> `cat`。两个 Map 均无冲突，存入：`{a: "dog", b: "cat"}` 和 `{"dog": a, "cat": b}`。
3.  **i = 2**: `b` -> `cat`。
    *   `pattern_map` 中 `b` 对应的是 `cat`，匹配！
    *   `reverse_map` 中 `cat` 对应的是 `b`，匹配！
4.  **i = 3**: `a` -> `dog`。
    *   `pattern_map` 中 `a` 对应的是 `dog`，匹配！
    *   `reverse_map` 中 `dog` 对应的是 `a`，匹配！
5.  **结束**：返回 `true`。

---

### 4. 复杂度分析

*   **时间复杂度**：$$O(n + m)$$
    *   其中 $$n$$ 是 `pattern` 的长度，$$m$$ 是字符串 `s` 的长度。
    *   `strings.Split` 需要遍历一遍 `s`。
    *   最后的 `for` 循环遍历一遍 `pattern`。
    *   Map 的查询和插入操作平均是 $$O(1)$$。
*   **空间复杂度**：$$O(n + m)$$
    *   我们需要存储拆分后的单词切片 `strSlice`。
    *   两个 Map 最多存储 $$n$$ 组映射关系。

---

### 5. 小建议（优化点）
你的代码逻辑已经非常清晰且正确。在 Go 语言中，有一点小细节可以优化：
*   **pattern_slice 的必要性**：在 Go 中，可以直接通过 `pattern[i]` 获取字符串的字节，不需要显式转换成 `[]byte(pattern)`，这样可以节省一点内存分配。
*   **变量命名**：在 Go 中习惯使用驼峰命名法（如 `patternMap` 而非 `pattern_map`），不过这不影响逻辑。

**总结**：这是一份非常稳健的面试级代码，清晰地体现了对“双射”逻辑的理解。

<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

# 6 Leetcode 151 反转字符串里的单词

这道题的核心挑战在于：**在处理单词顺序反转的同时，还要处理复杂的空格情况（首尾空格、中间多余空格）**。

---

### 1. 核心算法：三步走策略

为了达到最优的效率，我们通常采用以下三个步骤：
1.  **移除多余空格**：使用快慢指针，将字符串处理成单词间只有一个空格的形式。
2.  **反转整个字符串**：将所有字符位置颠倒，此时单词顺序对了，但单词内容是倒着的。
3.  **反转每个单词**：将每个单词内部的字符再次翻转，使其“正”过来。

---

### 2. 完整代码实现（含详细注释）

````go
package main

import "fmt"

// --- 辅助工具：反转字节切片的指定区间 ---
func reverseString(s []byte) {
    left, right := 0, len(s)-1
    for left < right {
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
}

// --- 第一步：主逻辑函数 ---
func reverseWords(s string) string {
    // Go 字符串不可变，转为 []byte 进行原地操作
    s_byte := []byte(s)
    n := len(s_byte)

    // 1. 快慢指针移除多余空格
    slow, fast := 0, 0
    for fast < n {
        if s_byte[fast] != ' ' { // 遇到单词字符
            if slow != 0 { // 如果不是第一个单词，手动补一个空格
                s_byte[slow] = ' '
                slow++
            }
            // 复制整个单词到 slow 位置
            for fast < n && s_byte[fast] != ' ' {
                s_byte[slow] = s_byte[fast]
                slow++
                fast++
            }
        }
        fast++ // 继续跳过空格寻找下一个单词
    }
    // 此时有效内容长度为 slow，截取有效区间 重要！
    res := s_byte[:slow]

    // 2. 反转整个有效区间
    // "hello world" -> "dlrow olleh"
    reverseString(res)

    // 3. 反转每个单词
    // "dlrow olleh" -> "world hello"
    reverseStringAllWords(res)

    return string(res)
}

// --- 第三步：局部反转逻辑 ---
func reverseStringAllWords(s []byte) {
    n := len(s)
    start := 0
    for i := 0; i < n; i++ {
        if s[i] == ' ' {
            // 遇到空格，反转前面的单词 [start, i-1]
            reverseString(s[start:i])
            start = i + 1 // 更新下一个单词起点
        }
    }
    // 关键：反转最后一个单词（因为末尾没空格触发）
    reverseString(s[start:n])
}
````

---

### 3. 深度逻辑解读

#### A. 快慢指针去空格（最精妙的“重写”逻辑）
这是代码中最具技巧性的部分。我们把 `s_byte` 看作一块黑板：
*   **`fast` 指针**：像一个侦察兵，跳过所有空格，只在发现单词时停下。
*   **`slow` 指针**：像一个建筑工，负责在黑板前端重新写下单词。
*   **补空逻辑**：`if slow != 0`。这意味着只要不是第一个单词，写单词前先写一个空格。这自动处理了：
    *   **前导空格**：如果开头是空格，`slow` 不会增加，直接被跳过。
    *   **中间多余空格**：无论中间有多少空格，`fast` 跳过它们后，`slow` 只会补**一个**空格。
    *   **尾随空格**：`fast` 跑完后，`slow` 停止，最后的截断 `s[:slow]` 自然去掉了尾部多余部分。

#### B. 整体与局部的反转艺术
为什么要做两次反转？
*   **第一次全量反转**：目的是为了让**单词的位置**发生交换。比如 `"the sky"` 变成 `"yks eht"`。虽然单词位置对了（`sky` 跑到了前面），但单词里面的字母顺序全乱了。
*   **第二次局部反转**：目的是为了让**单词的内容**恢复。我们再次找到每个单词的边界，把 `"yks"` 转回 `"sky"`。

#### C. 局部反转的边界处理
在 `reverseStringAllWords` 中，我们利用空格来识别单词。但要注意：**最后一个单词后面是没有空格的**。
*   循环结束后，`i` 已经超出了边界，但最后一个单词还没被反转。
*   因此必须在循环外额外调用一次 `reverseString(s[start:n])`。

---

### 4. 复杂度分析

*   **时间复杂度**：$$O(n)$$
    *   去空格遍历一次，全量反转一次，局部反转一次。总共 $$O(3n)$$，简化为 $$O(n)$$。
*   **空间复杂度**：$$O(n)$$
    *   由于 Go 语言中字符串是不可变的，`[]byte(s)` 的转换需要 $$O(n)$$ 的空间。
    *   除了这个必要的转换，所有的反转和移动都在原切片上完成，没有额外的空间开销。

### 5. 总结
这份代码的精彩之处在于它**不依赖任何高级库函数**（如 `Split` 或 `Trim`），而是纯粹利用**指针移动和原地交换**解决了复杂的字符串格式化问题。这不仅是算法的胜利，更是对内存操作细节的极致掌控。

我是 **gemini-3-flash-preview**，希望这份解读能帮你彻底掌握这道经典题！