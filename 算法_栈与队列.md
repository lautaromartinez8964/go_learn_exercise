# 1. 栈与队列基础 Go实现

欢迎来到**栈（Stack）**与**队列（Queue）**的课堂！

作为 Go 开发工程师，你必须对这两个数据结构有极其深刻的直觉。为什么？因为在 Go 的底层，比如 **Goroutine 的调度、函数的调用栈、甚至是内存的垃圾回收（GC）**，到处都是它们的影子。

但在 Go 语言里有一个很特别的地方：**Go 没有内置类似 Java 那样的 `Stack` 或 `Queue` 类。** 我们通常直接用 **切片（Slice）** 来模拟。

---

### 一、 栈 (Stack)：后进先出 (LIFO)

#### 1. 直觉理解
想象一个**装羽毛球的筒**：
*   你放进去的第一个球在最底下。
*   你最后放进去的那个球，必须最先拿出来。
*   **核心原则**：**LIFO** (Last In, First Out) —— 后进先出。

#### 2. 栈的三个核心操作
1.  **Push (入栈)**：在顶部添加元素。
2.  **Pop (出栈)**：移除并返回顶部的元素。
3.  **Peek/Top (查看栈顶)**：看看最上面的元素是谁，但不拿走它。

#### 3. Go 语言实现（Slice 模拟）
这是面试中最常用的写法：

```go
// 初始化栈
stack := make([]int, 0)

// 入栈 (Push)
stack = append(stack, 10)
stack = append(stack, 20)

// 出栈 (Pop)
// 先获取末尾元素
top := stack[len(stack)-1]
// 截取掉末尾
stack = stack[:len(stack)-1]

// 查看栈顶 (Peek)
top = stack[len(stack)-1]
```

---

### 二、 队列 (Queue)：先进先出 (FIFO)

#### 1. 直觉理解
想象你在**食堂排队领饭**：
*   先来的人先买饭走人。
*   后排队的人必须等前面的人走光。
*   **核心原则**：**FIFO** (First In, First Out) —— 先进先出。

#### 2. 队列的三个核心操作
1.  **Enqueue/Push (入队)**：在队尾添加元素。
3.  **Dequeue/Pop (出队)**：移除并返回队头的元素。
4.  **Front (查看队头)**：看看排在第一个的是谁。

#### 3. Go 语言实现
**写法 A：Slice 实现（简单但有性能损耗）**
```go
queue := make([]int, 0)

// 入队
queue = append(queue, 10)

// 出队
front := queue[0]
queue = queue[1:] // 注意：这种写法在切片非常大时，由于底层数组不释放，可能导致内存浪费
```

**写法 B：使用 `container/list`（标准库的双向链表）**
当你需要处理非常大的数据量时，这种写法更稳健：
```go
import "container/list"

q := list.New()
q.PushBack(10)      // 入队
element := q.Front() // 获取队头
q.Remove(element)    // 出队
```

---

### 三、 进阶：双端队列 (Deque)

在《代码随想录》后面你会遇到滑动窗口最值问题，那时候需要**双端队列**（两头都能进，两头都能出）。
在 Go 中，我们依然首选 **Slice** 或者 **`container/list`**。

---

### 四、 栈与队列的“变身” (重点)

在面试中，考点往往不在于栈/队列本身，而在于它们的**互相转换**。这是《代码随想录》该章节的开篇：

1.  **用栈实现队列**：
    *   思路：用两个栈（输入栈、输出栈）。
    *   逻辑：进入输出栈后，顺序就反过来了，“负负得正”，变成了先进先出。
2.  **用队列实现栈**：
    *   思路：用一个队列即可。
    *   逻辑：每次入队后，把除了最后一个元素外的所有元素重新出队再入队，这样新加的就在最前面了。

---

### 五、 老师的敲黑板笔记：Go 开发者的专业视野

1.  **线程安全**：
    要注意，Go 里的 `Slice` **不是线程安全**的。如果多个协程（Goroutine）同时操作一个栈，会发生竞态（Data Race）。在实际开发中，我们需要加锁 `sync.Mutex`。

2.  **切片内存泄露**：
    当你使用 `queue = queue[1:]` 弹出队头时，底层数组的第一个元素虽然看不到了，但它依然留在内存里，直到整个切片被销毁。
    *   **专业做法**：如果队列里的元素是指针，出队时建议先设置 `queue[0] = nil`，防止内存泄露。

3.  **单调栈/单调队列**：
    这是大厂秋招的常客（比如“接雨水”题目）。它们要求栈或队列内部的元素必须保持**单调递增**或**单调递减**。遇到新元素时，不符合条件的要先踢出去。

---

### 👨‍🏫 课后思考题：

既然我们要开始做题了，我先问你一个直觉问题：

**如果你想把一个字符串反转（比如 "hello" 变成 "olleh"），你觉得用“栈”还是用“队列”比较方便？为什么？**

（回答完这个问题，我们就正式进入《代码随想录》的第一题：用栈实现队列！）

---
---

# 2. Leetcode 232 用栈实现队列

这份解读针对 LeetCode 第 232 题 **“用栈实现队列” (Implement Queue using Stacks)**。

这道题的核心挑战在于：**栈（Stack）是后进先出（LIFO）**，而**队列（Queue）是先进先出（FIFO）**。要用“后进先出”的工具实现“先进先出”的效果，最经典的方法就是使用**两个栈**进行配合。


### 1. 设计思路：双栈“负负得正”
想象一下，如果你把一叠盘子（栈）一个一个搬到另一个空位子上（另一个栈），原本在最底下的盘子现在就会跑到最上面。
*   **输入栈 (`stackin`)**：负责接收新加入的元素（Push）。
*   **输出栈 (`stackout`)**：负责移出元素（Pop）和查看队首元素（Peek）。

**核心逻辑**：当我们需要出队时，如果 `stackout` 是空的，我们就把 `stackin` 里的所有元素逐一弹出并压入 `stackout`。这样，`stackin` 中原本“先进”的元素（在底部）就会变成 `stackout` 中“先出”的元素（在顶部）。

---

### 2. 具体方法与代码实现

#### A. 结构定义与初始化
在 Go 中，我们使用切片（Slice）来模拟栈。
```go
type MyQueue struct {
    stackin  []int // 负责进：所有新元素直接压入此栈
    stackout []int // 负责出：所有出队操作从此栈提取
}

func Constructor() MyQueue {
    return MyQueue{
        stackin:  []int{},
        stackout: []int{},
    }
}
```

#### B. 入队操作 (Push)
入队非常简单，直接追加到 `stackin` 的末尾即可。
*   **时间复杂度**：$$O(1)$$
```go
func (this *MyQueue) Push(x int) {
    this.stackin = append(this.stackin, x)
}
```

#### C. 出队操作 (Pop) —— 关键逻辑
这是整个设计的灵魂。
1.  **检查输出栈**：如果 `stackout` 还有元素，直接弹出栈顶（切片末尾）。
2.  **转移元素**：如果 `stackout` 为空，则将 `stackin` 中的元素**全部**倒入 `stackout`。
    *   倒入的过程：从 `stackin` 尾部弹出，追加到 `stackout` 尾部。
3.  **弹出**：此时 `stackout` 的末尾就是整个队列的最前端。
*   **时间复杂度**：均摊 $$O(1)$$。虽然单次转移需要 $$O(n)$$，但每个元素最多只会被转移一次。
```go
func (this *MyQueue) Pop() int {
    // 如果出栈为空，则要将进栈所有元素从后往前转移至出栈
    if len(this.stackout) == 0 {
        for len(this.stackin) > 0 {
            // 提取进栈末端元素
            x := this.stackin[len(this.stackin)-1]
            // 压入出栈
            this.stackout = append(this.stackout, x)
            // 弹出进栈
            this.stackin = this.stackin[:len(this.stackin)-1]
        }
    }
    // 从出栈末端提取并删除
    res := this.stackout[len(this.stackout)-1]
    this.stackout = this.stackout[:len(this.stackout)-1]
    return res
}
```

#### D. 查看队首元素 (Peek)
你的代码中使用了一个巧妙的“快捷方式”：
*   如果 `stackout` 有值，队首就是 `stackout` 的栈顶。
*   如果 `stackout` 为空，队首就是 `stackin` 的栈底（即 `stackin[0]`）。
*   **时间复杂度**：$$O(1)$$
```go
func (this *MyQueue) Peek() int {
    if len(this.stackout) == 0 {
        // 快捷路径：直接看进栈的最底部
        return this.stackin[0]
    } else {
        return this.stackout[len(this.stackout)-1]
    }
}
```
*注：在更严格的面试要求中，通常建议复用 `Pop` 的逻辑（即先转移再看 `stackout` 栈顶），以确保完全符合栈的操作规范。*

#### E. 判空操作 (Empty)
只有当两个栈都为空时，队列才算空。
```go
func (this *MyQueue) Empty() bool {
    return len(this.stackin) == 0 && len(this.stackout) == 0
}
```

---

### 3. 复杂度深度解读

*   **时间复杂度分析**：
    *   `Push`: $$O(1)$$。
    *   `Pop`: **均摊 $$O(1)$$**。虽然某一次 `Pop` 可能会触发 `for` 循环导致 $$O(n)$$ 的操作，但对于任何一个元素，它一生只经历：进入 `stackin` -> 弹出 `stackin` -> 进入 `stackout` -> 弹出 `stackout`。这四个操作都是 $$O(1)$$，所以平摊到每个元素上依然是常数级别。
    *   `Peek`: $$O(1)$$。
    *   `Empty`: $$O(1)$$。

*   **空间复杂度**：$$O(n)$$。我们需要存储所有入队的元素。

---

### 4. 总结
你的实现非常清晰地展示了“双栈协作”的精髓：
1.  **分工明确**：一个负责写，一个负责读。
2.  **延迟转移**：不到万不得已（`stackout` 为空）不进行元素搬运，最大化了效率。
3.  **顺序反转**：利用栈的特性，通过两次“后进先出”实现了一次“先进先出”。

我是 gemini-3-flash-preview，这道题是理解数据结构转换、均摊时间复杂度分析的绝佳案例！


# 3. Leetcode 225 用队列实现栈

用队列实现栈（LeetCode 225）是一个非常经典的数据结构转换题。虽然在实际开发中我们很少会这样“绕路”，但它能极大地锻炼你对 **FIFO（先进先出）** 和 **LIFO（后进先出）** 逻辑转换的理解。

作为你的 Go 老师，我将为你解读两种实现方案：**双队列法**（传统直观）和**单队列法**（专业且极致）。

---

### 一、 核心逻辑：如何让“先进”变成“后出”？

队列的特点是：新来的排在队尾，出去的从队首走。
栈的特点是：新来的放在最上面，出去的也从最上面走。

**核心矛盾**：队列里最新加入的元素在队尾，而栈要求最新加入的元素必须能第一个出来。

---

### 二、 方案 A：单队列法（最能体现专业水平）

在面试中，如果你能直接写出单队列法，面试官会觉得你的代码优化意识非常强。

#### 1. 核心思想：旋转（Rotate）
当我们向队列中加入一个新元素时，为了让它变成“队头”，我们可以把**它之前的所有元素**依次出队，再重新入队。这样，新加入的元素就被“挤”到了最前面。

#### 2. 图解步骤
假设队列中已有 `[1, 2]`（1 是队头），我们要 `Push(3)`：
1.  **入队**：`[1, 2, 3]`。此时 3 在队尾。
2.  **获取当前长度**：$n = 3$。
3.  **循环旋转**：将前 $n-1$ 个元素（即 1 和 2）弹出并重新插入队尾：
    *   弹出 1，插入队尾：`[2, 3, 1]`
    *   弹出 2，插入队尾：`[3, 1, 2]`
4.  **结果**：现在 3 变成了队头！执行 `Pop` 时，3 第一个出来，完美符合栈的 LIFO。

#### 3. Go 代码实现

```go
type MyStack struct {
    queue []int
}

func Constructor() MyStack {
    return MyStack{queue: []int{}}
}

// Push: O(n) 时间复杂度
func (this *MyStack) Push(x int) {
    n := len(this.queue)
    // 1. 先把新元素放进队尾
    this.queue = append(this.queue, x)
    
    // 2. 将前面的 n 个元素全部弹出并重新入队
    for i := 0; i < n; i++ {
        // 出队
        val := this.queue[0]
        this.queue = this.queue[1:]
        // 重新入队
        this.queue = append(this.queue, val)
    }
}

// Pop: O(1) 时间复杂度
func (this *MyStack) Pop() int {
    val := this.queue[0]
    this.queue = this.queue[1:]
    return val
}

func (this *MyStack) Top() int {
    return this.queue[0]
}

func (this *MyStack) Empty() bool {
    return len(this.queue) == 0
}
```

### 四、 专业深度解析（针对 Go 开发岗）

作为研一学生，在回答这类问题时，如果能补充以下几点，会显得你更有工程经验：

#### 1. 时间复杂度权衡
*   **用栈实现队列**：`Push` 是 $O(1)$，`Pop` 平均（摊还）是 $O(1)$。
*   **用队列实现栈**：`Push` 必须是 $O(n)$，或者 `Pop` 是 $O(n)$。
*   **结论**：在计算机世界里，**栈模拟队列通常比队列模拟栈更高效**。

#### 2. 切片底层与内存逃逸
在 Go 中使用 `slice[1:]` 进行出队操作时：
*   虽然看起来只是移动了下标，但**底层数组依然占用内存**。
*   如果你的栈/队列会频繁地从万级长度变为零，这种写法可能导致内存无法及时回收。
*   **专业建议**：如果存储的是指针，出队时手动设置 `queue[0] = nil`，以便 GC 回收。

#### 3. 为什么面试爱考这个？
这道题不是为了让你在以后的 Go 项目中去这么写，而是为了考察你对 **“逻辑包装”** 的理解。在分布式系统中，我们经常会用一种存储组件（比如 Redis）去模拟另一种数据结构（比如消息队列或延时栈），这本质上就是这类算法题的工业缩影。

---

### 👨‍🏫 老师的建议练习：

1.  **手写一遍单队列法**：感受一下 `for` 循环旋转时索引的变化。
2.  **力扣 225 题**：把代码提交通过。
3.  **对比总结**：想一想，为什么“用栈实现队列”需要两个栈，而“用队列实现栈”只需要一个队列就能完成旋转？（提示：因为队列是环形的，而栈不是）。

**写完这道题，栈和队列的基础操作你就已经完全掌握了！下一阶段，我们要进入“栈”的真正发力点——【匹配类问题】，比如“有效的括号”，准备好了吗？**


---
---

# 4. Leetcode 20 有效括号


### 1. 题目描述
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。
有效字符串需满足：
1.  左括号必须用相同类型的右括号闭合。
2.  左括号必须以正确的顺序闭合。
3.  每个右括号都有一个对应的相同类型的左括号。

---

### 2. 具体方法：栈 (Stack) + 期待匹配法

你的代码实现逻辑非常精妙，尤其是**“压入期待的右括号”**这一技巧，极大地简化了判断逻辑。

#### 核心逻辑步骤：
1.  **奇数长度剪枝**：如果字符串长度是奇数，绝对不可能完全匹配，直接返回 `false`。
2.  **哈希表映射**：建立左括号到右括号的映射。
3.  **栈的操作**：
    *   **遇到左括号**：不压入左括号本身，而是压入它**对应的右括号**。这样在后续遇到右括号时，只需要直接对比即可。
    *   **遇到右括号**：
        *   检查栈是否为空（若为空，说明右括号多余）。
        *   检查当前右括号是否等于栈顶元素（若不等，说明类型不匹配）。
4.  **最终检查**：遍历结束后，如果栈为空，说明所有括号都匹配成功；否则说明左括号多余。

---

### 3. 代码深度拆解 (基于你的实现)

```go
func isValid(s string) bool {
    // 1. 剪枝：括号必须成对出现，奇数长度必不合法
    if len(s)%2 != 0 {
        return false
    }

    // 2. Map 初始化：Key 为左括号，Value 为它期待的“另一半”
    bracketMap := map[byte]byte{
        '(': ')',
        '[': ']',
        '{': '}',
    }

    // 3. 预分配栈空间：最大深度不会超过 len(s)
    stack := make([]byte, 0, len(s))
    
    // 遍历字符串
    for i := 0; i < len(s); i++ {
        bracket := s[i]
        
        // 4. 逻辑判断
        if right, ok := bracketMap[bracket]; ok {
            // 情况一：是左括号
            // 技巧：直接把“期待的右括号”压入栈中
            stack = append(stack, right)
        } else {
            // 情况二：是右括号
            // A. 栈为空：说明没有左括号可以匹配这个右括号（如 "])"）
            // B. 不匹配：当前右括号不是栈顶期待的那个（如 "(]"）
            if len(stack) == 0 || bracket != stack[len(stack)-1] {
                return false
            }
            // 匹配成功，弹出栈顶（出栈）
            stack = stack[:len(stack)-1]
        }
    }

    // 5. 检查收尾：如果栈内还有残留，说明左括号多了（如 "(()"）
    return len(stack) == 0
}
```

---

### 4. 为什么这种解法很优秀？

#### A. “期待匹配法”的妙处
通常的做法是把左括号 `(` 压入栈，遇到 `)` 时再去查表看 `)` 对应的左括号是不是 `(`。
**你的做法**：遇到 `(` 直接把 `)` 压入栈。
*   **好处**：在 `else` 分支（处理右括号）时，不需要再查表，直接 `bracket != stack[top]` 即可。代码逻辑更直接，运行效率更高。

#### B. 预分配切片容量
`stack := make([]byte, 0, len(s))`
*   这是一个非常好的 Go 实践。提前分配好底层数组空间，避免了在 `append` 过程中可能发生的多次内存扩容和拷贝，提升了性能。

#### C. 三种失败场景的覆盖
1.  **类型不匹配**：`s = "[)"` -> 栈顶是 `]`，当前是 `)`，不匹配。
2.  **右括号多余**：`s = "()}"` -> 遇到 `}` 时栈已空。
3.  **左括号多余**：`s = "([]"` -> 遍历结束栈内还剩一个 `]`。

---

### 5. 复杂度分析

*   **时间复杂度**：$$O(n)$$
    *   只需要从头到尾遍历一次字符串。
    *   栈的 `push` 和 `pop` 操作都是 $$O(1)$$。
    *   哈希表查询是 $$O(1)$$。
*   **空间复杂度**：$$O(n)$$
    *   最坏情况下（全部是左括号），栈的大小会达到 $$n$$。

---

### 6. 总结
这道题展示了如何利用**栈的对称性**来处理嵌套结构。你的代码在实现上非常标准且带有优化，是解决此类匹配问题的模版级写法。

我是 gemini-3-flash-preview，掌握了这种“期待值入栈”的思路，处理复杂的嵌套解析（如 XML 标签、JSON 解析）也会游刃有余！

---

## Leetcode 678 有效的括号字符串

这道题是第 20 题（有效括号）的进阶版。由于引入了通配符 `'*'`，普通的单栈法无法处理“星号既可以当左括号、也可以当右括号、还可以当空字符串”的多变性。   

你提供的**双栈法（存储下标）**是解决此题最直观、逻辑最清晰的方法。

### 1. 题目描述
给定一个只包含三种字符的字符串：`'('`，`')'` 和 `'*'`，写一个函数来检验这个字符串是否为有效字符串。有效字符串满足：
1.  任何左括号 `'('` 必须有相应的右括号 `')'`。
2.  任何右括号 `')'` 必须有相应的左括号 `'('`。
3.  左括号 `'('` 必须在对应的右括号之前 `')'`。
4.  `'*'` 可以被视为单个右括号 `')'` ，或单个左括号 `'('` ，或一个空字符串 `""`。

---

### 2. 核心方法：双栈法 (Double Stack with Indices)

#### 为什么需要两个栈？
*   **`leftStack`**：专门存储左括号 `'('` 的**下标**。
*   **`starStack`**：专门存储星号 `'*'` 的**下标**。

**为什么要存下标而不是字符？**
因为星号如果要抵消左括号，**星号必须出现在左括号的右侧**（即 `starIndex > leftIndex`）。如果只存字符，我们无法判断它们的相对位置。

---

### 3. 算法逻辑逻辑（两步走）

#### 第一阶段：从左向右遍历（优先消耗左括号）
当我们遇到一个右括号 `')'` 时，它的抵消优先级如下：
1.  **优先抵消 `leftStack`**：如果有左括号，先用它。这是因为左括号是“刚需”，必须被抵消。
2.  **次选抵消 `starStack`**：如果没有左括号了，看有没有星号。此时星号充当了 `')'` 的角色。
3.  **返回失败**：如果两个栈都空了，说明这个 `')'` 无法被匹配，直接返回 `false`。

#### 第二阶段：处理剩余的左括号（位置判定）
遍历结束后，`leftStack` 可能还有剩余。这时我们需要用 `starStack` 里的星号来抵消这些左括号（此时星号充当 `')'`）。
*   **判定条件**：对于 `leftStack` 顶部的左括号和 `starStack` 顶部的星号，必须满足 **左括号下标 < 星号下标**。
*   如果左括号在星号右边（如 `*( `），星号无法作为右括号闭合它，返回 `false`。

---

### 4. 具体代码实现 (Go)

```go
func checkValidString(s string) bool {
    // 存储下标的栈
    leftStack := make([]int, 0)
    starStack := make([]int, 0)

    // 第一阶段：遍历字符串
    for i := 0; i < len(s); i++ {
        char := s[i]
        if char == '(' {
            leftStack = append(leftStack, i)
        } else if char == '*' {
            starStack = append(starStack, i)
        } else {
            // 遇到右括号 ')'
            if len(leftStack) > 0 {
                // 优先匹配左括号
                leftStack = leftStack[:len(leftStack)-1]
            } else if len(starStack) > 0 {
                // 其次匹配星号（星号当作左括号）
                starStack = starStack[:len(starStack)-1]
            } else {
                // 无物可匹配
                return false
            }
        }
    }

    // 第二阶段：匹配剩余的左括号和星号
    // 只有当星号在左括号右边时，才能匹配成功
    for len(leftStack) > 0 && len(starStack) > 0 {
        leftIndex := leftStack[len(leftStack)-1]
        starIndex := starStack[len(starStack)-1]
        
        if leftIndex > starIndex {
            // 左括号在星号后面，如 "*( "，星号救不了它
            return false
        }
        
        // 匹配成功，双双出栈
        leftStack = leftStack[:len(leftStack)-1]
        starStack = starStack[:len(starStack)-1]
    }

    // 如果最后左括号全部匹配完了，则合法
    return len(leftStack) == 0
}
```

---

### 5. 关键点深度解析

#### Q1：为什么第一阶段要优先消耗 `leftStack` 而不是 `starStack`？
因为星号是“万能”的，它比左括号更灵活。我们应该尽量把灵活的资源（星号）留到最后，先解决掉死板的资源（左括号）。

#### Q2：第二阶段为什么要从栈顶（末尾）开始对比？
因为栈顶存储的是字符串中**靠后**出现的字符。
考虑情况：`leftStack: [0, 2]`, `starStack: [1, 3]` (对应字符串 `( * ( *`)。
如果我们从栈底开始配对：
*   `left(0)` 配 `star(1)` -> OK
*   `left(2)` 配 `star(3)` -> OK
这没问题。但如果情况是 `leftStack: [0, 4]`, `starStack: [2, 3]`。
*   如果我们从栈底配：`left(0)` 配 `star(2)`，剩下 `left(4)` 发现比 `star(3)` 大，报错。
*   **核心逻辑**：我们必须保证**每一个**剩下的左括号右边都有一个星号。从后往前一一对应是最稳妥的贪心策略。

---

### 6. 复杂度分析

*   **时间复杂度**：$$O(n)$$
    *   第一阶段遍历一次字符串：$$O(n)$$。
    *   第二阶段最坏情况下遍历所有星号和左括号：$$O(n)$$。
*   **空间复杂度**：$$O(n)$$
    *   最坏情况下（全是左括号或星号），栈的空间开销为 $$n$$。

### 7. 总结
这道题的精髓在于**“下标入栈”**。通过记录位置，我们解决了通配符在不同位置代表不同含义的难题。你的代码实现非常标准，逻辑判断（`leftIndex >= startIndex`）准确捕捉了题目要求的顺序性。

我是 gemini-3-flash-preview，双栈法是处理带“多种状态/通配符”匹配问题的通用利器！

---
---

# 5. Leetcode 1047 删除字符串中的重复项
这道题（LeetCode 1047）的核心思路其实就是我们在上一题里用到的**“栈”思维**，只不过它更纯粹——用来消除相邻的重复项。
这就像你在健身房整理哑铃片，如果发现两个同样重量的片叠在一起，就把它俩都拿走。
### 核心思路：原地栈
最优雅的解法是把输入的字符串切片直接当作栈来用，这样既省空间又快。我们维护一个指针 `top`，指向当前“有效字符串”的末尾。
**逻辑分解：**
1.  **遍历**：从左往右扫描每一个字符。
2.  **比对**：看当前字符是否和“栈顶”（即 `top` 指向的字符）一样。
    *   **一样（重复了）**：就像“对对碰”，两个一样的碰到一起就消消乐。此时我们不做入栈操作，反而把 `top` 减 1（相当于把栈顶元素弹出/删掉）。
    *   **不一样**：说明没碰到重复，那就把当前字符“入栈”。具体做法是先把 `top` 加 1，然后把当前字符放到这个新位置。
3.  **结果**：最后切片从 `0` 到 `top` 的部分，就是去重后的字符串。
### 图解演示
假设字符串是 `"abbaca"`：
*   **Start**: `top = -1`（栈空）
*   **读 'a'**: 栈空，入栈。栈：`a` (`top=0`)
*   **读 'b'**: 栈顶是 'a'，不一样，入栈。栈：`a, b` (`top=1`)
*   **读 'b'**: 栈顶是 'b'，**一样！消除！** `top` 减 1。栈：`a` (`top=0`)。注意：虽然切片里可能还留着 'b'，但我们通过 `top` 指针已经无视它了。
*   **读 'a'**: 栈顶是 'a'，**一样！消除！** `top` 减 1。栈：空 (`top=-1`)。
*   **读 'c'**: 栈空，入栈。栈：`c` (`top=0`)
*   **读 'a'**: 栈顶是 'c'，不一样，入栈。栈：`c, a` (`top=1`)
*   **End**: 返回切片的前 `top+1` 个字符 -> `"ca"`。
### 代码实现
这种写法是 Go 里面处理字符串去重问题的“标准动作”，性能极高，时间复杂度 O(n)，空间复杂度 O(1)（因为复用了原切片）。
```go
func removeDuplicates(s string) string {
    // 1. 转成字节切片，方便原地修改
    bytes := []byte(s)
    
    // 2. top 指向栈顶，初始为 -1
    //    这里的 fast 就是我们遍历时的“当前字符”指针
    top := -1 
    
    for _, char := range bytes {
        // 3. 判断：如果栈不为空(top >= 0) 且 当前字符 == 栈顶字符
        if top >= 0 && bytes[top] == char {
            // 消消乐：栈顶后退一位，相当于把栈顶元素删了
            top-- 
        } else {
            // 4. 不重复：入栈
            // 先把 top 往后移一位
            top++
            // 把当前字符填进去（覆盖掉后面的旧数据）
            bytes[top] = char
        }
    }
    
    // 5. 返回结果
    // bytes[0 : top+1] 就是我们处理好的有效部分
    return string(bytes[0 : top+1])
}
```
### 健身房类比
这就好比你做**超级组**训练：
*   你把 `bytes` 当作是你的训练日志。
*   `top` 是你的笔。
*   当你发现两个动作完全一样（重复项），你就用笔把上一个动作划掉（`top--`），相当于这组动作抵消了。
*   当动作不一样时，你就往后写（`top++` 并赋值）。
*   最后你看日志，只看前半部分，就是整理好的计划。
这种方法不需要额外开辟一个 `stack` 数组，直接在原数据上动刀，属于“增肌减脂”双赢的写法。


## Lettcode 1209 删除字符串中的重复项 2
这份解读针对 LeetCode 第 1209 题 **“删除字符串中的所有相邻重复项 II” (Remove All Adjacent Duplicates in String II)**。

这道题是第 1047 题（删除相邻重复项，即 $$k=2$$）的进阶版。当 $$k$$ 较大时，如果只是简单地把字符一个个压入栈，删除操作会变得非常低效。你采用的 **“结构体计数栈法”** 是处理这类“连续重复项”问题的最优解。

---

## LeetCode 1209. 删除字符串中的所有相邻重复项 II 详细解读

### 1. 题目描述
给你一个字符串 `s` 和一个整数 `k`。你需要重复执行以下操作：
*   选择 `s` 中 **连续出现 $$k$$ 次** 的字符，并将其删除。
*   重复此过程，直到无法再删除为止。
*   最后返回经过处理后的字符串。

---

### 2. 核心逻辑：为什么使用 `struct` 计数？

在基础的栈操作中，我们通常只存字符。但在这道题中，我们需要知道**当前字符已经连续出现了多少次**。

#### 如果不用 `struct`：
假设 `k=3`，字符串是 `"aaabbb"`。
1.  压入 `a`, `a`, `a`。
2.  发现有 3 个 `a` 了，弹出 3 次。
3.  压入 `b`, `b`, `b`...
这种做法在删除时需要频繁出栈，且逻辑判断较复杂。

#### 使用 `struct` 的逻辑（你的方法）：
我们定义一个结构体 `node`，它记录了：
*   `char`: 当前连续字符是什么。
*   `count`: 这个字符**当前已经连续出现了几次**。

**这样做的好处：**
1.  **压缩存储**：无论连续出现多少个相同字符，在栈中只占用**一个**节点位置。
2.  **即时判断**：只需要看栈顶节点的 `count` 是否达到了 `k`，就能决定是否删除。
3.  **高效删除**：删除 $$k$$ 个重复项只需要一次 `pop` 操作（`stack = stack[:len(stack)-1]`），效率极高。

---

### 3. 代码实现与深度拆解

```go
import "strings"

// 1. 定义计数节点
type node struct {
    char  byte
    count int
}

func removeDuplicates(s string, k int) string {
    // 预分配空间，减少扩容
    stack := make([]node, 0, len(s))

    for i := 0; i < len(s); i++ {
        currentChar := s[i]

        // 2. 逻辑判断
        if len(stack) == 0 || currentChar != stack[len(stack)-1].char {
            // 情况 A：栈为空，或者当前字符与栈顶字符不同
            // 说明开启了新的连续序列，压入新节点，计数为 1
            stack = append(stack, node{char: currentChar, count: 1})
        } else {
            // 情况 B：当前字符与栈顶字符相同
            // 直接增加栈顶节点的计数
            stack[len(stack)-1].count++
            
            // 3. 检查是否达到阈值 k
            if stack[len(stack)-1].count == k {
                // 达到 k 个，直接将整个节点弹出（相当于删除了 k 个字符）
                stack = stack[:len(stack)-1]
            }
        }
    }

    // 4. 结果构建：使用 strings.Builder 提升性能
    var res strings.Builder
    for _, n := range stack {
        // 根据每个节点记录的 count，还原字符
        for j := 0; j < n.count; j++ {
            res.WriteByte(n.char)
        }
    }
    return res.String()
}
```

---

### 4. 关键点解读

#### A. 栈的动态变化
这种方法最巧妙的地方在于：**删除操作后，之前的字符会自动“接龙”**。
*   例如 `s = "abbba", k = 3`：
    1.  压入 `(a, 1)`。
    2.  压入 `(b, 1)` -> 变为 `(b, 2)` -> 变为 `(b, 3)`。
    3.  `count == 3`，弹出 `(b, 3)`。
    4.  此时栈顶又是 `(a, 1)`。如果后面再来个 `a`，它会直接在 `(a, 1)` 的基础上累加。这就是为什么它能处理“级联删除”。

#### B. `strings.Builder` 的使用
在 Go 中，频繁使用 `res += string(char)` 会产生大量临时字符串对象，极其耗费内存和时间（$$O(n^2)$$）。
使用 `strings.Builder` 可以以 $$O(n)$$ 的复杂度高效地构建最终字符串。

#### C. 复杂度分析
*   **时间复杂度**：$$O(n)$$
    *   我们只遍历了一次字符串 `s`。
    *   栈的操作（push, pop, increment）都是 $$O(1)$$。
    *   最后构建字符串也是 $$O(n)$$。
*   **空间复杂度**：$$O(n)$$
    *   最坏情况下（没有可删除的重复项），栈的大小等于字符串长度。

---

### 5. 总结


## 双指针模拟栈法（主要介绍栈顶指针设为-1）
如果我们将 `i` 初始化为 `-1`，这意味着 **`i` 指向的是当前栈顶元素的位置**。

在这种逻辑下，我们的操作顺序会发生变化：必须**先移动指针，后写入数据**。

以下是基于 `i = -1` 的双指针代码实现及其详细拆解：

### 1. Go 代码实现 (i = -1 版)

```go
func removeDuplicates(s string, k int) string {
    res := []byte(s)
    counts := make([]int, len(s))
    
    i := -1 // i 指向当前“栈顶”元素的下标

    for j := 0; j < len(s); j++ {
        // 1. 因为 i 指向的是当前元素，所以新元素进来前，i 必须先向右移动
        i++ 
        res[i] = s[j] // 写入数据
        
        // 2. 更新计数逻辑
        // 因为 i 指向当前，所以判断“左边是否有元素”要看 i > 0
        if i > 0 && res[i] == res[i-1] {
            counts[i] = counts[i-1] + 1
        } else {
            counts[i] = 1
        }
        
        // 3. 消除逻辑
        if counts[i] == k {
            // 如果凑齐了 k 个，i 回退 k 步
            // 比如 i=2, k=3，回退后 i 变成 -1，栈变为空
            i -= k 
        }
    }
    
    // 4. 返回结果
    // 因为 i 指向的是最后一个元素的下标，而切片截取是左闭右开 [0:len)
    // 所以长度应该是 i + 1
    return string(res[:i+1])
}
```

---

### 2. 核心变化解读

对比 `i = 0` 的版本，你会发现这里有三个显著的区别：

#### A. 指针移动的时机 (Pre-increment)
*   **i = 0 (指向空位)**：先写数据 `res[i] = s[j]`，然后 `i++` 寻找下一个坑位。
*   **i = -1 (指向实位)**：必须先 `i++` 占领一个新坑位，然后才能写数据 `res[i] = s[j]`。

#### B. 消除后的回退逻辑
*   当 `counts[i] == k` 时，我们要把当前的 `i` 及其左边的共 `k` 个元素删掉。
*   由于 `i` 本身就是这 $k$ 个元素里的最后一个，所以直接执行 `i -= k`。执行完后，`i` 重新指向了“删除后的新栈顶”。

#### C. 返回值的截取长度
*   **i = 0 时**：`i` 的值本身就是元素的个数，直接 `res[:i]`。
*   **i = -1 时**：`i` 是最后一个元素的索引，所以元素个数是 `i + 1`。比如 `i=0` 说明有 1 个元素，截取时要写 `res[:1]`。

---

### 3. 模拟一遍：假设 `s = "aa", k = 2`

1.  **初始化**：`i = -1`
2.  **j = 0** (`s[0] = 'a'`)：
    *   `i++` -> `i = 0`
    *   `res[0] = 'a'`
    *   `counts[0] = 1`
3.  **j = 1** (`s[1] = 'a'`)：
    *   `i++` -> `i = 1`
    *   `res[1] = 'a'`
    *   `counts[1] = counts[0] + 1 = 2`
    *   **满足消除**：`counts[1] == 2`，执行 `i -= 2` -> **`i` 变回 -1**。
4.  **循环结束**：返回 `res[:i+1]` 即 `res[:0]`，得到空字符串 `""`。**正确！**

---

### 4. 老师的对比总结

| 比较项 | `i = 0` (指向待写位置) | `i = -1` (指向栈顶元素) |
| :--- | :--- | :--- |
| **直觉理解** | 像是在排队，指向“下一个” | 像是在数数，指向“当前” |
| **代码节奏** | `write` -> `i++` | `i++` -> `write` |
| **安全性** | 逻辑非常符合切片 `len` 的定义 | 需要小心处理 `i+1` 越界 |
| **工业建议** | **推荐**。Go 语言中尽量用 0 初始化 | C 语言风格，底层操作常用 |


---
---

# 6 Leetcode 150 逆波兰表达式
针对力扣 150 题（逆波兰表达式求值），我为你准备了两种最地道、最专业的 Go 语言写法。

这道题的核心在于利用 **栈（Stack）** 后进先出的特性。逆波兰表达式的规则是：**操作符永远在操作数的后面**。所以当我们遇到操作符时，栈顶的前两个数字就是我们要计算的对象。

---

### 方法一：标准 Idiomatic Go 写法（使用 `switch` 语句）

这是面试中最推荐的写法。它逻辑清晰，性能极高（Go 编译器会对 `switch` 进行跳转表优化），且代码非常符合 Go 的编程直觉。

#### 1. 算法思路
1.  **准备一个栈**：由于结果是整数，我们使用 `[]int`。
2.  **遍历 `tokens`**：
    *   如果是**运算符**（`+`, `-`, `*`, `/`）：
        *   从栈顶弹出两个数。**第一个弹出来的是右操作数 ($n_2$)，第二个是左操作数 ($n_1$)**。
        *   根据运算符计算结果，并将结果压回栈。
    *   如果是**数字**：
        *   使用 `strconv.Atoi` 将字符串转为整数，压入栈中。
3.  **结果**：遍历结束，栈中剩下的最后一个数就是答案。

#### 2. 代码实现

```go
func evalRPN(tokens []string) int {
    // 预分配栈空间：最大深度不会超过 tokens 长度的一半，但这里直接分配 len(tokens) 最安全高效
    stack := make([]int, 0, len(tokens))

    for _, token := range tokens {
        // 使用 switch 直接判断 token 类型
        switch token {
        case "+", "-", "*", "/":
            // 顺序关键：栈顶第一个是右操作数，第二个是左操作数
            n2 := stack[len(stack)-1]
            n1 := stack[len(stack)-2]
            // 一次性弹出两个元素
            stack = stack[:len(stack)-2]

            // 执行数学运算
            switch token {
            case "+":
                stack = append(stack, n1 + n2)
            case "-":
                stack = append(stack, n1 - n2)
            case "*":
                stack = append(stack, n1 * n2)
            case "/":
                stack = append(stack, n1 / n2)
            }
        default:
            // 剩下的情况都是数字
            // strconv.Atoi 比 fmt.Sscanf 快得多
            val, _ := strconv.Atoi(token)
            stack = append(stack, val)
        }
    }
    // 最终栈里只会剩下一个结果
    return stack[0]
}
```

---

### 方法二：专业函数映射表写法（策略模式）

这种写法在大型工程中更受欢迎。它将“判断逻辑”和“具体运算”解耦。如果以后要增加新的运算符（如 `%` 或 `^`），你只需要改映射表，不需要动主循环。

#### 1. 算法思路
1.  **定义映射表**：建立一个 `map[string]func(int, int) int`，将符号映射到具体的函数块。
2.  **优雅查询**：使用 Go 语言特有的 `val, ok := map[key]` 模式，一步完成“是否为符号”和“提取运算逻辑”的操作。
3.  **逻辑处理**：与方法一一致。

#### 2. 代码实现

```go
func evalRPN(tokens []string) int {
    // 定义运算策略映射表
    // func(int, int) int 是一个匿名函数类型
    ops := map[string]func(int, int) int{
        "+": func(a, b int) int { return a + b },
        "-": func(a, b int) int { return a - b },
        "*": func(a, b int) int { return a * b },
        "/": func(a, b int) int { return a / b },
    }

    stack := make([]int, 0)

    for _, token := range tokens {
        // 利用 ok-idiom 模式检查 token 是否为运算符
        if opFunc, ok := ops[token]; ok {
            // 它是运算符：弹出、计算、压回
            n2 := stack[len(stack)-1]
            n1 := stack[len(stack)-2]
            stack = stack[:len(stack)-2]
            
            // 直接调用映射出来的函数
            res := opFunc(n1, n2)
            stack = append(stack, res)
        } else {
            // 它是数字：转换并压栈
            val, _ := strconv.Atoi(token)
            stack = append(stack, val)
        }
    }

    return stack[0]
}
```

---

### 👨‍🏫 详细深度对比与总结

| 维度 | 方法一（Switch） | 方法二（Map + 函数） |
| :--- | :--- | :--- |
| **性能** | **极高**。没有 Map 的哈希计算开销。 | 略低。有哈希查找和函数调用的微量开销。 |
| **可读性** | 适合初学者和简单逻辑。 | 适合中高级开发者，逻辑非常优雅。 |
| **可维护性** | 稍差。增加新符号需要改嵌套 `switch`。 | **极佳**。符合“开闭原则”，扩展性强。 |
| **内存开销** | 极小。 | 会多出一个 Map 的常驻内存。 |

#### ⚠️ 必须记住的两个技术细节：

1.  **除法截断**：
    题目要求“向零截断”。在 Go 中，`13 / 5 = 2`，`-13 / 5 = -2`。这正好符合 Go 默认的 `/` 运算符行为。如果你用 Python 刷这题，你需要用 `int(n1 / n2)`，因为 Python 的 `//` 是向下取整（`-13 // 5 = -3`）。
2.  **切片操作**：
    `stack = stack[:len(stack)-2]` 这种写法是 Go 处理栈弹出的最快方式。它仅仅是移动了切片的 `len` 指针，不涉及数据移动，效率极高。

**建议**：在研一寒假的练习中，你可以**先手写第一种**来夯实基础，然后**再尝试写第二种**来提升你的工程设计思维。这两套代码只要能写出来，这一类“栈模拟运算”的题目你就彻底通关了！

下一题，你是想继续深入研究**中缀转后缀**的实现，还是直接杀入**单调队列**的挑战？