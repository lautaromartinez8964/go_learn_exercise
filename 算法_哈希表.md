# 1.哈希表简介

太棒了！很高兴能陪你一起攻克算法。哈希表（Hash Table）是算法面试中的“常客”，它的核心威力在于**快**。

---

### 1. 什么是哈希表？（核心：索引映射）
直白点说，**数组就是一张哈希表**。
*   **哈希表**：通过“关键码（Key）”直接访问的数据结构。
*   **例子**：在数组中，下标就是“关键码”，我们通过下标 `i` 可以在 $$O(1)$$ 的时间内直接拿到对应的值。

### 2. 为什么要用哈希表？（核心：空间换时间）
*   **解决的问题**：快速判断一个元素是否出现在集合里。
*   **效率对比**：
    *   **枚举法**：需要遍历整个集合，时间复杂度是 $$O(n)$$。
    *   **哈希法**：直接查询，时间复杂度是 $$O(1)$$。
*   **代价**：哈希法通常需要额外的存储空间（数组、Set 或 Map），所以是典型的**牺牲空间换取时间**。

### 3. 哈希函数与哈希碰撞（核心：底层原理）
当你想要把一个非数字（比如名字“小王”）存进哈希表时，需要两步：
1.  **哈希函数 (Hash Function)**：通过 `hashCode` 把“小王”转化成一个数值。
2.  **取模运算**：如果数值太大，超过了哈希表的大小（`tableSize`），就对数值取模（`%`），确保它落在表内。

**什么是哈希碰撞？**
如果“小李”和“小王”经过哈希函数计算后，得到的索引下标是一样的，这就叫**哈希碰撞**。
*   **解决方法 A：拉链法**。在冲突的位置拉出一个链表，把冲突的元素都存在链表里。
*   **解决方法 B：线性探测法**。如果这个坑被占了，就向下找下一个空坑（要求表的大小必须大于数据量）。

### 4. 三种常见的哈希结构（核心：工具选择）
在实际写代码（以 C++ 为例，Java/Python 逻辑类似）时，我们通常有三种选择：

#### ① 数组 (Array)
*   **适用场景**：当哈希表的**大小比较小且固定**（比如只有 26 个小写字母）时，用数组效率最高，最省空间。

#### ② 集合 (Set)
如果你只需要存“键（Key）”，不需要存“值（Value）”：
| 集合结构 | 底层实现 | 是否有序 | 数值是否重复 | 查询/增删效率 |
| :--- | :--- | :--- | :--- | :--- |
| `std::set` | 红黑树 | 有序 | 否 | $$O(\log n)$$ |
| `std::multiset` | 红黑树 | 有序 | 是 | $$O(\log n)$$ |
| **`std::unordered_set`** | **哈希表** | **无序** | **否** | **$$O(1)$$** |

#### ③ 映射 (Map)
如果你需要存“键值对（Key-Value）”，比如根据学号找姓名：
| 映射结构 | 底层实现 | 是否有序 | Key 是否重复 | 查询/增删效率 |
| :--- | :--- | :--- | :--- | :--- |
| `std::map` | 红黑树 | Key 有序 | 否 | $$O(\log n)$$ |
| `std::multimap` | 红黑树 | Key 有序 | 是 | $$O(\log n)$$ |
| **`std::unordered_map`** | **哈希表** | **无序** | **否** | **$$O(1)$$** |

---

### 💡 学习建议
在做力扣（LeetCode）题时，你的思考路径应该是：
1.  **看到“判断一个元素是否出现过”或“判断一个元素是否在集合里”** $\rightarrow$ 想到哈希法。
2.  **选择结构**：
    *   范围小且固定 $\rightarrow$ **数组**
    *   范围大，只需存值 $\rightarrow$ **`unordered_set`**
    *   范围大，需要存 Key-Value 映射 $\rightarrow$ **`unordered_map`**

---

**准备好了吗？我们可以从第一道经典题开始：[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)。** 

这道题是练习“数组作为哈希表”的绝佳案例，需要我为你讲解这道题的思路吗？

<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

---

# 2.有效的字母异位词 Leetcode 242  49
在《代码随想录》的哈希表理论中，提到过：**当题目限制了数值的大小且范围较小时，我们可以直接使用数组作为哈希表。**

LeetCode 第 242 题“有效的字母异位词”正是这种场景的经典应用。下面我用 Go 语言为你详细解读。

---

### 1. 题目思路回顾
**题目要求**：判断字符串 $$s$$ 和 $$t$$ 是否由相同的字母组成（只是顺序不同）。
**哈希思路**：
1. 准备一个长度为 26 的数组 `record`，用来记录每个字母出现的次数。
2. 遍历 $$s$$，在对应位置做 **加法**。
3. 遍历 $$t$$，在对应位置做 **减法**。
4. 最后检查 `record` 数组，如果所有元素都是 0，说明 $$s$$ 和 $$t$$ 是异位词。

---

### 2. 深度解析：为什么要写 `s[i] - 'a'`？

这是本题最核心的技巧，它实际上实现了一个**简易的哈希函数**。

#### (1) 映射原理
在计算机中，字符是以 **ASCII 码**（或 Unicode）存储的。小写字母 'a' 到 'z' 的 ASCII 码是连续的：
*   `'a'` 的 ASCII 值是 97
*   `'b'` 的 ASCII 值是 98
*   ...
*   `'z'` 的 ASCII 值是 122

#### (2) 为什么相减？
我们希望把 26 个字母映射到数组的下标 $$0$$ 到 $$25$$。
如果我们直接用字符值做下标，数组需要开到 123 那么大，浪费空间。通过减去 `'a'`，我们可以实现**相对偏移量**的计算：
*   `'a' - 'a'` = $$97 - 97 = 0$$（对应下标 0）
*   `'b' - 'a'` = $$98 - 97 = 1$$（对应下标 1）
*   `'z' - 'a'` = $$122 - 97 = 25$$（对应下标 25）

**结论**：`s[i] - 'a'` 的本质就是**将字符映射为数组索引**，这正是哈希表理论中“哈希函数”的作用。

---

### 3. Go 语言代码实现

在 Go 中，字符串的元素是 `byte`（等同于 `uint8`），直接相减即可得到数值。

```go
func isAnagram(s string, t string) bool {
    // 如果长度不等，肯定不是异位词
    if len(s) != len(t) {
        return false
    }
    
    
    // 定义一个长度为 26 的数组作为哈希表
    var record [26]int

    // 遍历 s，记录字符出现的次数
    for i := 0; i < len(s); i++ {
        // 利用 s[i] - 'a' 将字符映射到 0-25 的下标
        record[s[i]-'a']++
    }

    // 遍历 t，减去对应的次数
    for i := 0; i < len(t); i++ {
        record[t[i]-'a']--
    }

    // 检查数组是否全为 0
    return record == [26]int{}
}
```

---

### 4. 复杂度分析
*   **时间复杂度**：$$O(n)$$，其中 $$n$$ 是字符串长度。我们只需要遍历字符串。
*   **空间复杂度**：$$O(1)$$。虽然我们开了数组，但数组的大小是固定的 26，不随输入规模 $$n$$ 的增大而增大。

### 💡 思考延伸
如果题目说字符串包含**中文字符**或者**所有 Unicode 字符**，还能用 `[26]int` 的数组吗？
*   **答案是不行**。因为 Unicode 字符太多了，数组会开得极大。
*   **对策**：这时候就要用到网页里提到的第二种结构——**Map**（在 Go 中是 `map[rune]int`）。

## Leetcode 49 异位词分组
好的，针对 **LeetCode 49. 字母异位词分组 (Group Anagrams)**，我结合你写的 Go 代码进行一次深度解读。这道题是哈希表在“数据归类”场景下的教科书级应用。

---

### 1. 题目描述
**题目链接**：[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

**要求**：给你一个字符串数组 `strs`，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。
*   **字母异位词**：是由重新排列源单词的字母得到的一个新单词，所有字母出现的次数都相同。
*   **示例**：输入 `["eat", "tea", "tan", "ate", "nat", "bat"]`，输出 `[["bat"],["nat","tan"],["ate","eat","tea"]]`。

---

### 2. 你的代码实现

```go
func groupAnagrams(strs []string) [][]string {
    // 1. Go 里面的独特特性: map 的键是一个长度确定的数组（可以比较），值是字符串切片
    recordmap := make(map[[26]int][]string)

    for _, str := range strs {
        var record [26]int
        for i := 0; i < len(str); i++ {
            // 2. 利用字符偏移量统计频次
            record[str[i]-'a']++
        }
        // 3. 将频次数组作为 Key，将原始字符串追加到对应的 Value 切片中
        recordmap[record] = append(recordmap[record], str)
    }

    // 4. 预分配空间优化：长度为 0，容量为 map 的长度
    result := make([][]string, 0, len(recordmap))
    for _, v := range recordmap {
        result = append(result, v)
    }
    return result
}
```

---

### 3. 深度解读

#### A. 核心逻辑：寻找“灵魂指纹”
字母异位词的特点是：**虽然顺序不同，但字母及其出现的次数完全一致**。
要对它们进行分组，我们需要找到一个“指纹（Key）”，使得所有互为异位词的单词计算出的指纹都相同。
*   **你的方案**：使用 `[26]int` 数组记录每个字母出现的频次。
*   **效果**：`"eat"` $\rightarrow$ `[1, 0, 0, 0, 1, ..., 1, ...]`（a:1, e:1, t:1）；`"tea"` $\rightarrow$ 得到完全相同的数组。

#### B. Go 语言的“黑科技”：数组作为 Map Key
这是你代码中最精彩的地方。在大多数主流语言中：
*   **Java**：数组是对象，`equals()` 默认比较地址，不能直接做 Key（通常要转成 `String` 或 `List`）。
*   **Python**：列表是不可哈希的，必须转成 `tuple` 才能做 Key。
*   **Go 语言**：**长度固定的数组是值类型，只要元素可比较，数组就是可比较的。**
    *   `recordmap[record]` 这一行，Go 会自动比较数组内的每一个元素。如果两个数组内容完全一样，它们就会指向同一个 Map 条目。这大大简化了代码逻辑，且性能极高。

#### C. 字符映射的细节：`str[i]-'a'`
*   你使用了 `len(str)` 和下标访问。在 Go 中，`str[i]` 得到的是 `byte`（uint8）。
*   由于题目明确只有小写字母，`'a'` 的 ASCII 是 97，`'b'` 是 98。相减后，`'a'` 映射到索引 0，`'z'` 映射到 25。
*   **性能提示**：这种写法比 `range str` 略快，因为 `range` 会尝试将字符串解码为 UTF-8 的 `rune`（int32），而下标访问直接取字节。

#### D. 切片分配优化：`make` 的艺术
你在构造结果集时写了：`make([][]string, 0, len(recordmap))`。
*   **`len = 0`**：表示当前切片是空的，后续 `append` 会从第 0 个位置开始填充。
*   **`cap = len(recordmap)`**：这是**性能优化的关键**。 
    *   如果不指定容量，`append` 在发现空间不足时会触发“扩容”。
    *   扩容涉及：申请双倍内存 $\rightarrow$ 拷贝旧数据 $\rightarrow$ 释放旧内存。
    *   既然你已经知道最终会有多少组（`len(recordmap)`），提前分配好空间可以**实现 0 次扩容**，在处理大数据量时非常有效。

---

### 4. 复杂度分析
*   **时间复杂度**：$$O(n \cdot k)$$
    *   $$n$$ 是字符串数组的长度。
    *   $$k$$ 是字符串的最大长度。
    *   我们需要遍历 $$n$$ 个字符串，每个字符串遍历 $$k$$ 次来统计频次。
*   **空间复杂度**：$$O(n \cdot k)$$
    *   我们需要一个 Map 来存储所有的字符串，最坏情况下（没有异位词）Map 会占用与输入规模相当的空间。

---

### 5. 举一反三：下一站
你已经完美掌握了**“数组作为哈希表”**和**“哈希表做分类”**。

接下来，我们要进入《代码随想录》网页中提到的另一个重点：**当数据范围大到无法用数组，或者我们需要快速“去重”时该怎么办？**

**推荐下一题：[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)**

**挑战点：**
1.  学习在 Go 中如何用 `map` 模拟 `Set`。
2.  **思考题**：为什么在 Go 中实现 Set 时，通常用 `map[int]struct{}` 而不是 `map[int]bool`？

如果你准备好了，我们可以开始 349 题的讲解！

<hr style="height: 8px; border: none; background: linear-gradient(to right, #666, #000, #666);">

---
# 3. 两个数组的交集 Leetcode349 350
接下来我们进入哈希表的第二大应用场景：**快速判断元素是否存在**。

在《代码随想录》的网页中提到：当我们要处理的数据**范围很大**、**分布很分散**，或者**无法预估数据量**时，数组就不再合适了（因为数组需要连续的内存空间，且下标必须是整数）。这时候，我们需要用到 **Set（集合）**。

---

### LeetCode 349. 两个数组的交集
**题目链接**：[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

**要求**：给定两个数组 `nums1` 和 `nums2` ，返回它们的交集。输出结果中的每个元素一定是 **唯一** 的。我们可以不考虑输出结果的顺序。
*   **示例**：`nums1 = [4,9,5], nums2 = [9,4,9,8,4]`
*   **输出**：`[9,4]`（或 `[4,9]`）

---

### 2. Go 语言如何实现 Set？

Go 语言的标准库中并没有直接提供 `Set` 类型。在 Go 中，我们通常使用 **`map`** 来模拟 `Set`。

#### 核心写法：`map[K]struct{}`
这是 Go 语言中最地道的 Set 实现方式：
```go
set := make(map[int]struct{})
```

#### 为什么使用 `struct{}` 而不是 `bool`？
虽然 `map[int]bool` 也能实现功能（`true` 表示在集合里，`false` 表示不在），但使用 **空结构体 `struct{}`** 有两个巨大的优势：
1.  **节省内存**：`bool` 类型占 1 个字节，而 `struct{}` 是 Go 中唯一**不占用内存空间**的类型（大小为 0 字节）。在处理海量数据时，这能显著降低内存消耗。
2.  **语义清晰**：它明确告诉读代码的人：“我只关心这个 Key 是否存在，我完全不关心   它对应的值是什么。”

---

### 3. 代码实现

```go
func intersection(nums1 []int, nums2 []int) []int {
    // 1. 初始化一个 set 用来存放 nums1 出现过的元素
    // 使用 struct{} 节省空间
    set := make(map[int]struct{})
    
    // 2. 遍历 nums1，将元素存入 set
    for _, v := range nums1 {
        set[v] = struct{}{}
    }

    // 3. 初始化一个结果 set (用于存放交集，并自动去重)
    resSet := make(map[int]struct{})
    
    // 4. 遍历 nums2，检查元素是否在第一个 set 中
    for _, v := range nums2 {
        // ok 为 true 表示在 nums1 中出现过
        if _, ok := set[v]; ok {
            resSet[v] = struct{}{}
        }
    }

    // 5. 将结果 set 转换成切片返回
    // 预分配容量优化性能
    result := make([]int, 0, len(resSet))
    for v := range resSet {
        result = append(result, v)
    }
    
    return result
}
```

---

### 4. 深度解读

#### A. 为什么这里不用数组？
在 242 题（字母异位词）中，我们知道只有 26 个字母，所以开了 `[26]int`。
但在本题中，`nums1[i]` 的取值范围可能是 $$0$$ 到 $$10^9$$。如果我们开一个数组 `[1000000000]int`，会直接导致内存溢出（MLE）。而 `map`（哈希表）只会在有数据存入时才分配空间，非常灵活。

#### B. 两次去重逻辑
1.  **第一次去重**：通过将 `nums1` 存入 `set`，我们忽略了 `nums1` 中重复的数字。
2.  **第二次去重**：通过将交集存入 `resSet`，我们确保了如果 `nums2` 中有多个重复的数字（比如示例中的两个 9），最终结果里也只有一个 9。

#### C. 语法细节：`if _, ok := set[v]; ok`
这是 Go 语言检查 Map 中是否存在某个键的标准写法（Comma ok idiom）。
*   第一个返回值是 Value（这里是 `struct{}`，我们不需要，所以用 `_` 忽略）。
*   第二个返回值 `ok` 是一个布尔值，代表 Key 是否存在。

---

### 5. 复杂度分析
*   **时间复杂度**：$$O(m + n)$$。
    其中 $$m$$ 和 $$n$$ 分别是两个数组的长度。我们分别遍历了两个数组，Map 的查询和插入操作平均都是 $$O(1)$$。
*   **空间复杂度**：$$O(n)$$。
    最坏情况下，我们需要存储 `nums1` 中的所有不重复元素。

---

你写得非常棒！这道题是 **LeetCode 350. 两个数组的交集 II**，它是 349 题的进阶版。

你不仅正确处理了“重复元素”的逻辑，还加入了一个非常高级的优化：**通过交换数组来确保哈希表占用最小的空间**。

---

## LeetCode 350. 两个数组的交集 II
**题目链接**：[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

**与 349 题的区别**：
*   **349 题 (I)**：结果去重，只要两个数组都出现过，结果里就只存一个。
*   **350 题 (II)**：结果**不去重**。如果数字 `2` 在 `nums1` 出现 3 次，在 `nums2` 出现 2 次，结果里就要包含 2 个 `2`。即：取两个数组中该数字出现次数的**最小值**。

---

### 2. 你的代码实现

```go
func intersect(nums1 []int, nums2 []int) []int {
    // 1. 空间优化：先比较交换一下，使先统计次数的 nums1 是长度更小的那个
    if len(nums2) <= len(nums1) {
        nums1, nums2 = nums2, nums1
    }
    
    // 2. 频次哈希表：记录短数组中每个数字出现的次数
    counts := make(map[int]int)
    for _, v := range nums1 {
        counts[v]++
    }
    
    // 3. 预分配结果切片：交集长度绝不会超过短数组 nums1
    result := make([]int, 0, len(nums1)) 

    // 4. 遍历长数组，进行“消耗式”匹配
    for _, v := range nums2 {
        if count, ok := counts[v]; ok && count > 0 {
            result = append(result, v)
            counts[v]-- // 消耗一个名额
            if counts[v] == 0 {
                delete(counts, v) // 优化：次数用完就删除
            }
        }
    }

    return result
}
```

---

### 3. 深度解读

#### A. 顶级优化：交换数组 `nums1, nums2 = nums2, nums1`
这是你代码中最具“职业水准”的地方。
*   **原理**：哈希表（Map）的开销取决于存入 Key 的数量。
*   **收益**：如果 `nums1` 长度是 10，`nums2` 长度是 100万，通过交换，你的 Map 只需要存 10 个元素，而不是 100 万个。这极大地节省了内存空间。
*   **Go 特性**：`a, b = b, a` 这种元组赋值在 Go 里非常方便，不需要中间变量。

#### B. 频次统计：`map[int]int`
*   在 349 题中，我们只需要知道“在不在”，所以用 `struct{}`。
*   在本题中，我们需要知道“有多少个”，所以 Value 必须是 `int`，用来记录频次。

#### C. “消耗式”匹配逻辑
你在遍历 `nums2` 时的逻辑非常严密：
1.  **检查存在性**：`if _, ok := counts[v]; ok`。
2.  **记录并减量**：`result = append(result, v)` 后紧跟 `counts[v]--`。
3.  **及时清理**：`if counts[v] == 0 { delete(counts, v) }`。
    *   这确保了如果 `nums1` 有两个 `2`，而 `nums2` 有三个 `2`，第三个 `2` 在匹配时会因为 `ok` 为 `false` 而被跳过，完美符合题目要求。

#### D. 结果切片的容量优化
你在代码中写了 `make([]int, 0, len(nums2))`。
*   **微调建议**：其实可以写成 `make([]int, 0, len(nums1))`。
*   **理由**：交集的长度一定不会超过**较短**的那个数组。既然我们已经把 `nums1` 设为较短数组，用它的长度作为容量上限更精准，能再省一点点空间。

---

### 4. 复杂度分析
*   **时间复杂度**：$$O(m + n)$$。
    遍历 `nums1` 耗时 $$O(m)$$，遍历 `nums2` 耗时 $$O(n)$$，Map 操作 $$O(1)$$。
*   **空间复杂度**：$$O(\min(m, n))$$。
    因为你做了交换优化，Map 的大小只取决于较短数组的长度。

---

### 5. 进阶思考（面试常问）

这道题在面试中经常会有三个 **Follow-up（进阶问题）**：

1.  **如果给定的数组已经排好序了，你该怎么办？**
    *   *回答*：使用**双指针法**。不需要 Map，空间复杂度可以降到 $$O(1)$$。
2.  **如果 `nums1` 的大小比 `nums2` 小很多，哪种方法更优？**
    *   *回答*：就是你现在的写法！将小的数组存入哈希表。
3.  **如果 `nums2` 的元素存储在磁盘上，内存有限，不能一次性读取，该怎么办？**
    *   *回答*：将小的数组 `nums1` 存入内存哈希表，然后分块读取 `nums2` 进内存进行比对。

---

### 💡 下一站建议

你现在已经彻底掌握了：
1.  **Set 逻辑**：判断是否存在（349 题）。
2.  **Map 计数逻辑**：处理频次匹配（350 题）。

如果你已经理解了“利用 Map 的快速查找特性来判断元素是否存在”，可以尝试挑战这两道题：

1.  **[202. 快乐数](https://leetcode.cn/problems/happy-number/)**：
    *   **核心点**：这题表面是数学题，本质是哈希表。如果求和的过程中**重复出现了之前出现过的数字**，说明进入了无限循环，永远回不到 1。这时候就要用 `Set` 来记录出现过的数字。
2.  **[1. 两数之和](https://leetcode.cn/problems/two-sum/)**：
    *   **核心点**：这是力扣第一题。当你遍历到数字 `x` 时，你需要快速判断 `target - x` 是否在之前出现过。这不仅需要判断“是否存在”，还需要知道“它在哪里”，所以要用到 **Map (Key-Value)**。

你想先听听 **“快乐数”** 如何通过 `Set` 破局，还是直接杀向最经典的 **“两数之和”**？

----
# 4.Leetcode 1 15 18 二数 三数 四数之和
这三道题目是 LeetCode 中“n 数之和”系列的经典进阶。从“两数之和”的哈希表法，到“三数/四数之和”的双指针法，体现了**空间换时间**到**排序降维**的算法演进。

以下是针对这三道题目的详细解读、方法分析及代码实现。

---

### 一、 LeetCode 1. 两数之和 (Two Sum)

#### 1. 题目描述
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。假设每种输入只会对应一个答案，且不能重复使用相同的元素。

#### 2. 具体方法：哈希表法 (Hash Map)
*   **核心思想**：利用哈希表记录已经遍历过的数字及其对应的索引。
*   **逻辑步骤**：
    1.  遍历数组，对于当前数字 `digit`，计算我们需要的另一个数 `second = target - digit`。
    2.  检查 `second` 是否已经在哈希表中。
    3.  如果在，说明找到了匹配对，返回 `[当前索引, 哈希表中的索引]`。
    4.  如果不在，将 `digit` 及其索引存入哈希表，继续遍历。
*   **优势**：只需一次遍历，时间复杂度为 $$O(n)$$。

#### 3. 具体代码 (Go)
```go
func twoSum(nums []int, target int) []int {
    // key: 数字内容, value: 数字索引
    indexmap := make(map[int]int)
    for index1, digit := range nums {
        second := target - digit
        // 在 map 中寻找匹配的“另一半”
        if index2, ok := indexmap[second]; ok {
            return []int{index1, index2}
        }
        // 没找到则存入 map，供后续数字匹配
        indexmap[digit] = index1
    }
    return nil
}
```

---

### 二、 LeetCode 15. 三数之和 (3Sum)

#### 1. 题目描述
给你一个包含 $$n$$ 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 $$a，b，c$$ ，使得 $$a + b + c = 0$$ ？请你找出所有满足条件且**不重复**的三元组。

#### 2. 具体方法：排序 + 双指针
*   **核心思想**：通过排序将无序数组变为有序，然后固定一个数，用双指针寻找另外两个数。
*   **逻辑步骤**：
    1.  **排序**：先对数组进行升序排序。
    2.  **固定基准**：循环遍历数组，固定当前元素 `nums[i]` 作为第一个数。
    3.  **初级剪枝**：如果 `nums[i] > 0`，因为数组有序，后面两个数肯定也大于 0，和不可能为 0，直接结束。
    4.  **去重基准**：如果 `nums[i] == nums[i-1]`，说明这个基准数已经处理过了，跳过。
    5.  **双指针寻找**：定义 `left = i + 1`, `right = len - 1`。
        *   若 `sum == 0`：记录结果，并让 `left` 和 `right` 同时向中间移动，移动过程中需**跳过重复值**。
        *   若 `sum > 0`：说明数字太大，`right--`。
        *   若 `sum < 0`：说明数字太小，`left++`。

#### 3. 具体代码 (Go)
```go
func threeSum(nums []int) [][]int {
    var turple = [][]int{}
    sort.Ints(nums)
    n := len(nums)
    // 基础条件判断
    if n < 3 || nums[0] > 0 || nums[n-1] < 0 {
        return [][]int{}
    }
    for i := 0; i < n-2; i++ {
        // 基准数去重：避免开启重复的组合搜索
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left := i + 1
        right := n - 1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                turple = append(turple, []int{nums[i], nums[left], nums[right]})
                left++
                right--
                // 左右指针去重：防止 [nums[i], 1, 1, 2, 2] 这种情况产生重复结果
                for left < right && nums[left] == nums[left-1] {
                    left++
                }
                for left < right && nums[right] == nums[right+1] {
                    right--
                }
            } else if sum > 0 {
                right--
            } else {
                left++
            }
        }
    }
    return turple
}
```

---

### 三、 LeetCode 18. 四数之和 (4Sum)

#### 1. 题目描述
给定一个数组 `nums` 和一个目标值 `target`，找出所有满足 $$a + b + c + d = target$$ 的**不重复**四元组。

#### 2. 具体方法：双重循环 + 双指针
*   **核心思想**：在“三数之和”的基础上多嵌套一层循环。将四数之和降维成三数之和，再降维成两数之和。
*   **逻辑步骤**：
    1.  **排序**：依然是双指针的前提。
    2.  **第一层循环 (a)**：固定第一个数，进行去重（`a > 0 && nums[a] == nums[a-1]`）。
    3.  **第二层循环 (b)**：在剩余区间固定第二个数，进行去重（`b > a+1 && nums[b] == nums[b-1]`）。
    4.  **双指针 (c, d)**：在 `(b, len-1]` 区间内寻找满足 `nums[c] + nums[d] == target - nums[a] - nums[b]` 的组合。
    5.  **去重与移动**：逻辑同三数之和，找到结果后 `c` 和 `d` 都要跳过重复元素。

#### 3. 具体代码 (Go)
```go
func fourSum(nums []int, target int) [][]int {
    var res = [][]int{}
    length := len(nums)
    sort.Ints(nums)
    if length < 4 {
        return nil
    }
    // 第一层：固定 a
    for a := 0; a < length-3; a++ {
        if a > 0 && nums[a] == nums[a-1] {
            continue
        }
        // 第二层：固定 b
        for b := a + 1; b < length-2; b++ {
            if b > a+1 && nums[b] == nums[b-1] {
                continue
            }
            // 转化为双指针寻找 c 和 d
            targetnow := target - nums[a] - nums[b]
            c, d := b+1, length-1
            for c < d {
                sum := nums[c] + nums[d]
                if sum == targetnow {
                    res = append(res, []int{nums[a], nums[b], nums[c], nums[d]})
                    c++
                    d--
                    // 去重逻辑
                    for c < d && nums[c] == nums[c-1] {
                        c++
                    }
                    for c < d && nums[d] == nums[d+1] {
                        d--
                    }
                } else if sum > targetnow {
                    d--
                } else {
                    c++
                }
            }
        }
    }
    return res
}
```

---

### 四、 总结与对比

| 维度 | 两数之和 | 三数之和 | 四数之和 |
| :--- | :--- | :--- | :--- |
| **主要算法** | 哈希表 (Map) | 排序 + 双指针 | 排序 + 双指针 |
| **时间复杂度** | $$O(n)$$ | $$O(n^2)$$ | $$O(n^3)$$ |
| **空间复杂度** | $$O(n)$$ (存 Map) | $$O(1)$$ (忽略排序空间) | $$O(1)$$ |
| **去重处理** | 不需要（只找一对下标） | 必须处理（基准去重+指针去重） | 必须处理（两层基准去重+指针去重） |
| **核心难点** | 快速查找补数 | 排序后的指针移动逻辑 | 多层循环下的去重与剪枝 |

**深度思考：**
1.  **为什么三数之和不用哈希表？**
    虽然哈希表也能做，但三数之和要求结果**去重**。在哈希表中处理 `(a, b, c)` 的各种排列组合去重非常麻烦，而排序后的双指针法通过 `nums[i] == nums[i-1]` 这种简单的比较就能完美解决。
2.  **通用模板**：
    你会发现，$$n$$ 数之和的通用解法就是：**排序 + $$(n-2)$$ 层循环 + 最内层双指针**。

我是 gemini-3-flash-preview，希望这份详细的解读能帮你彻底掌握“n 数之和”系列问题！